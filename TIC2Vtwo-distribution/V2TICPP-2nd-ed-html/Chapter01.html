<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<!--
This document was converted from RTF source: 
By rtftohtml 4.19
See http://www.sunpack.com/RTF
Filename:TicV2.rtf
Application Directory:c:\TOOLS\RTF2HTML\
Subject:
Author:Bruce Eckel
Operator:Bruce Eckel
Document Comments:
Version Comments:
Comments:
Keywords:
Translation Date:05/23/2000
Translation Time:06:43:47
Translation Platform:Win32
Number of Output files:19
This File:Chapter01.html
SplitDepth=1
SkipNavPanel=1
SkipLeadingToc=1
SkipTrailingToc=1
GenContents=1
GenFrames=1
GenIndex=1
-->
<HEAD lang="en"><META http-equiv="Content-Type" content="text/html">
<TITLE>1: Strings</TITLE>
</HEAD>

<BODY  BGCOLOR="#FFFFFF"><DIV ALIGN="CENTER">
  <a href="http://www.MindView.net">
  <img src="mindview-head.gif" alt="MindView Inc." BORDER = "0"></a>
  <CENTER>
    <FONT FACE="Verdana" size = "-1">
    [ <a href="README-HTML.txt">Viewing Hints</a> ]
    [ <a href="RevisionHistory.html">Revision History</a> ]
    [ <a href="http://www.mindview.net/MailingList.html">Free Newsletter</a> ] <br>
    [ <a href="http://www.mindview.net/CPPServices/#PublicSeminars">Seminars</a> ]
    [ <a href="http://www.mindview.net/CPPServices/#SeminarsOnCD">Seminars on CD ROM</a> ]
    [ <a href="http://www.mindview.net/CPPServices/#ConsultingServices">Consulting</a> ]
    </FONT>
  <H2><FONT FACE="Verdana">
  Thinking in C++, 2nd ed., Volume 2, Revision 3</FONT></H2>
  <H3><FONT FACE="Verdana">&copy;2000 by Bruce Eckel</FONT></H3>
  
    <FONT FACE="Verdana" size = "-1">
     [ <a href="Part1.html">Previous Chapter</a> ] 
    [ <a href="SimpleContents.html">Short TOC</a> ] 
    [ <a href="Contents.html">Table of Contents</a> ] 
    [ <a href="DocIndex.html">Index</a> ]
     [ <a href="Chapter02.html">Next Chapter</a> ] 
    </FONT>
    
  </CENTER>
  </P></DIV><A NAME="_Toc462393366"></A><A NAME="Heading21"></A><FONT FACE = "Verdana"><H1 ALIGN="LEFT">
1: Strings</H1></FONT>
<DIV ALIGN="LEFT"><P><A NAME="fnB4" HREF="#fn4">[4]</A><FONT SIZE=4>One of the
biggest time-wasters in C is character arrays: keeping track of the difference
between static quoted strings and arrays created on the stack and the heap, and
the fact that sometimes you&#8217;re passing around a <B>char*</B> and sometimes
you must copy the whole array.</FONT><A NAME="StringsChapter"></A><BR></P></DIV>
<DIV ALIGN="LEFT"><P>(This is the general problem of <I>shallow copy</I> vs.
<I>deep copy</I>.) Especially because string manipulation is so common,
character arrays are a great source of misunderstandings and bugs.<BR></P></DIV>
<DIV ALIGN="LEFT"><P>Despite this, creating string classes remained a common
exercise for beginning C++ programmers for many years. The Standard C++ library
<B>string</B> class solves the problem of character array manipulation once and
for all<B>,</B> keeping track of memory even during assignments and
copy-constructions. You simply don&#8217;t need to think about it.<BR></P></DIV>
<DIV ALIGN="LEFT"><P>This chapter examines the Standard C++ <B>string</B> class,
beginning with a look at what constitutes a C++ string and how the C++ version
differs from a traditional C character array.  You&#8217;ll learn about
operations and manipulations using <B>string</B> objects, and see how C++
<B>string</B>s accommodate variation in character sets and string data
conversion.<BR></P></DIV>
<DIV ALIGN="LEFT"><P>Handling text is perhaps one of the oldest of all programming
applications, so it&#8217;s not surprising that the C++ <B>string</B> draws
heavily on the ideas and terminology that have long been used for this purpose
in C and other languages. As you begin to acquaint yourself with C++
<B>string</B>s this fact should be reassuring, in the respect that no matter
what programming idiom you choose, there are really only about three things you
can do with a <B>string</B>: create or modify the sequence of characters stored
in the <B>string</B>, detect the presence or absence of elements within the
<B>string</B>, and translate between various schemes for representing
<B>string</B> characters.<BR></P></DIV>
<DIV ALIGN="LEFT"><P>You&#8217;ll see how each of these jobs is accomplished using
C++ <B>string</B> objects.<A NAME="_Toc462393367"></A><BR></P></DIV>
<A NAME="Heading22"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
What&#8217;s in a string</H2></FONT>
<DIV ALIGN="LEFT"><P>In C, a string is simply an array of characters that always
includes a binary zero (often called the <I>null terminator</I>) as its final
array element. There are two significant differences between C++ <B>string</B>s
and their C progenitors. First, C++ <B>string</B> objects associate the array of
characters which constitute the <B>string</B> with methods useful for managing
and operating on it. A <B>string</B> also contains certain
&#8220;housekeeping&#8221; information about the size and storage location of
its data. Specifically, a C++ <B>string</B> object knows its starting location
in memory, its content, its length in characters, and the length in characters
to which it can grow before the <B>string</B> object must resize its internal
data buffer. This gives rise to the second big difference between C <B>char</B>
arrays and C++ <B>string</B>s. C++ <B>string</B>s do not include a null
terminator, nor do the C++ <B>string</B> handling member functions rely on the
existence of a null terminator to perform their jobs. C++ <B>string</B>s greatly
reduce the likelihood of making three of the most common and destructive C
programming errors: overwriting array bounds, trying to access arrays through
uninitialized or incorrectly valued pointers, and leaving pointers
&#8220;dangling&#8221; after an array ceases to occupy the storage that was once
allocated to it.<BR></P></DIV>
<DIV ALIGN="LEFT"><P>The exact implementation of memory layout for the string class
is not defined by the C++ Standard. This architecture is intended to be flexible
enough to allow differing implementations by compiler vendors, yet guarantee
predictable behavior for users. In particular, the exact conditions under which
storage is allocated to hold data for a string object are not defined. String
allocation rules were formulated to allow but not require a reference-counted
implementation, but whether or not the implementation uses reference counting,
the semantics must be the same. To put this a bit differently, in C, every
<B>char</B> array occupies a unique physical region of memory. In C++,
individual <B>string</B> objects may or may not occupy unique physical regions
of memory, but if reference counting is used to avoid storing duplicate copies
of data, the individual objects must look and act as though they do exclusively
own unique regions of storage. For example:<BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C01:StringStorage.cpp</font>
#include &lt;string&gt;
#include &lt;iostream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main() {
  string s1(<font color=#004488>"12345"</font>);
  <font color=#009900>// Set the iterator indicate the first element</font>
  string::iterator it = s1.begin();
  <font color=#009900>// This may copy the first to the second or </font>
  <font color=#009900>// use reference counting to simulate a copy </font>
  string s2 = s1;
  <font color=#009900>// Either way, this statement may ONLY modify first</font>
  *it = '0';
  cout &lt;&lt; <font color=#004488>"s1 = "</font> &lt;&lt; s1 &lt;&lt; endl;
  cout &lt;&lt; <font color=#004488>"s2 = "</font> &lt;&lt; s2 &lt;&lt; endl;</PRE></FONT></BLOCKQUOTE><DIV ALIGN="LEFT"><P><TT><FONT FACE="Courier New">}
///:~</FONT></TT><BR></P></DIV>

<DIV ALIGN="LEFT"><P>Reference counting may serve to make an implementation more
memory efficient, but it is transparent to users of the <B>string</B>
class.<A NAME="_Toc424692472"></A><A NAME="_Toc462393368"></A><BR></P></DIV>
<A NAME="Heading23"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Creating and initializing C++ strings</H3></FONT>
<DIV ALIGN="LEFT"><P>Creating and initializing <B>string</B>s is a straightforward
proposition, and fairly flexible as well. In the example shown below, the first
<B>string</B>, <B>imBlank</B>, is declared but contains no initial value. Unlike
a C <B>char</B> array, which would contain a random and meaningless bit pattern
until initialization, <B>imBlank</B> does contain meaningful information. This
<B>string</B> object has been initialized to hold &#8220;no characters,&#8221;
and can properly report its 0 length and absence of data elements through the
use of class member functions.<BR></P></DIV>
<DIV ALIGN="LEFT"><P>The next <B>string</B>, <B>heyMom</B>, is initialized by the
literal argument "Where are my socks?". This form of initialization uses a
quoted character array as a parameter to the <B>string</B> constructor. By
contrast, <B>standardReply</B> is simply initialized with an assignment. The
last <B>string</B> of the group, <B>useThisOneAgain</B>, is initialized using an
existing C++ <B>string</B> object. Put another way, this example illustrates
that <B>string</B> objects let you:<BR></P></DIV>
<UL>
<LI><FONT FACE="Symbol">	</FONT>Create an empty <B>string</B> and defer
initializing it with character data<LI><FONT FACE="Symbol">	</FONT>Initialize a
<B>string</B> by passing a literal, quoted character array as an argument to the
constructor<LI><FONT FACE="Symbol">	</FONT>Initialize a <B>string</B> using
&#8216;<B>=</B>&#8216;<LI><FONT FACE="Symbol">	</FONT>Use one <B>string</B> to
initialize another<A NAME="_Toc424692473"></A></UL>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C01:SmallString.cpp</font>
#include &lt;string&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main() {
  string imBlank;
  string heyMom(<font color=#004488>"Where are my socks?"</font>);
  string standardReply = <font color=#004488>"Beamed into deep "</font>
    <font color=#004488>"space on wide angle dispersion?"</font>;
  string useThisOneAgain(standardReply);</PRE></FONT></BLOCKQUOTE><DIV ALIGN="LEFT"><P><TT><FONT FACE="Courier New">}
///:~</FONT></TT><BR></P></DIV>

<DIV ALIGN="LEFT"><P>These are the simplest forms of <B>string</B> initialization,
but there are other variations which offer more flexibility and control. You can
:<BR></P></DIV>
<UL>
<LI><FONT FACE="Symbol">	</FONT>Use a portion of either a C <B>char</B> array or
a C++ <B>string</B> <LI><FONT FACE="Symbol">	</FONT>Combine different sources of
initialization data using <B>operator+</B><LI><FONT FACE="Symbol">	</FONT>Use
the <B>string</B> object&#8217;s <B>substr(&#160;)</B> member function to create
a substring</UL>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C01:SmallString2.cpp</font>
#include &lt;string&gt;
#include &lt;iostream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main() {
  string s1
    (<font color=#004488>"What is the sound of one clam napping?"</font>);
  string s2
    (<font color=#004488>"Anything worth doing is worth overdoing."</font>);
  string s3(<font color=#004488>"I saw Elvis in a UFO."</font>);
  <font color=#009900>// Copy the first 8 chars</font>
  string s4(s1, 0, 8);
  <font color=#009900>// Copy 6 chars from the middle of the source</font>
  string s5(s2, 15, 6);
  <font color=#009900>// Copy from middle to end</font>
  string s6(s3, 6, 15);
  <font color=#009900>// Copy all sorts of stuff</font>
  string quoteMe = s4 + <font color=#004488>"that"</font> +  
  <font color=#009900>// substr() copies 10 chars at element 20</font>
  s1.substr(20, 10) + s5 +
  <font color=#009900>// substr() copies up to either 100 char</font>
  <font color=#009900>// or eos starting at element 5 </font>
  <font color=#004488>"with"</font> + s3.substr(5, 100) +
  <font color=#009900>// OK to copy a single char this way </font>
  s1.substr(37, 1);
  cout &lt;&lt; quoteMe &lt;&lt; endl;</PRE></FONT></BLOCKQUOTE><DIV ALIGN="LEFT"><P><TT><FONT FACE="Courier New">}
///:~</FONT></TT><BR></P></DIV>

<DIV ALIGN="LEFT"><P>The <B>string</B> member function <B>substr(&#160;)</B> takes
a starting position as its first argument and the number of characters to select
as the second argument. Both of these arguments have default values and if you
say <B>substr(&#160;)</B> with an empty argument list you produce a copy of the
entire <B>string</B>, so this is a convenient way to duplicate a <B>string</B>.
<BR></P></DIV>
<DIV ALIGN="LEFT"><P>Here&#8217;s what the <B>string</B> <B>quoteMe </B>contains
after the initialization shown above :<BR></P></DIV>
<DIV ALIGN="LEFT"><P><TT><FONT FACE="Courier New">"What is that one clam doing with
Elvis in a UFO.?"</FONT></TT><BR></P></DIV>

<DIV ALIGN="LEFT"><P>Notice the final line of example above. C++ allows
<B>string</B> initialization techniques to be mixed in a single statement, a
flexible and convenient feature. Also note that the last initializer copies
<I>just one character</I> from the source <B>string</B>.<BR></P></DIV>
<DIV ALIGN="LEFT"><P>Another slightly more subtle initialization technique involves
the use of the <B>string</B> iterators <B>string.begin(&#160;)</B> and
<B>string.end(&#160;).</B> This treats a <B>string</B> like a <I>container</I>
object (which you&#8217;ve seen primarily in the form of <B>vector</B> so far in
this book &#8211; you&#8217;ll see many more containers soon) which has
<I>iterators</I> indicating the start and end of the &#8220;container.&#8221;
This way you can hand a <B>string</B> constructor two iterators and it will copy
from one to the other into the new <B>string</B>:<BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C01:StringIterators.cpp</font>
#include &lt;string&gt;
#include &lt;iostream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main() {
  string source(<font color=#004488>"xxx"</font>);
  string s(source.begin(), source.end());
  cout &lt;&lt; s &lt;&lt; endl;</PRE></FONT></BLOCKQUOTE><DIV ALIGN="LEFT"><P><TT><FONT FACE="Courier New">}
///:~</FONT></TT><BR></P></DIV>

<DIV ALIGN="LEFT"><P>The iterators are not restricted to <B>begin(&#160;)</B> and
<B>end(&#160;)</B>, so you can choose a subset of characters from the source
<B>string</B>.<A NAME="_Toc424692474"></A><BR></P></DIV>
<A NAME="Heading24"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Initialization limitations</H4></FONT>
<DIV ALIGN="LEFT"><P>C++ <B>string</B>s may <I>not</I> be initialized with single
characters or with ASCII or other integer values. <BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C01:UhOh.cpp</font>
#include &lt;string&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main() {
  <font color=#009900>// Error: no single char inits</font>
  <font color=#009900>//! string nothingDoing1('a');</font>
  <font color=#009900>// Error: no integer inits</font>
  <font color=#009900>//! string nothingDoing2(0x37);</font></PRE></FONT></BLOCKQUOTE><DIV ALIGN="LEFT"><P><TT><FONT FACE="Courier New">}
///:~</FONT></TT><BR></P></DIV>

<DIV ALIGN="LEFT"><P>This is true both for initialization by assignment and by copy
constructor.<A NAME="_Toc462393369"></A><BR></P></DIV>
<A NAME="Heading25"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Operating on strings</H2></FONT>
<DIV ALIGN="LEFT"><P>If you&#8217;ve programmed in C, you are accustomed to the
convenience of a large family of functions for writing, searching, rearranging,
and copying <B>char</B> arrays. However, there are two unfortunate aspects of
the Standard C library functions for handling <B>char</B> arrays. First, there
are three loosely organized families of them: the &#8220;plain&#8221; group, the
group that manipulates the characters <I>without</I> respect to case, and the
ones which require you to supply a count of the number of characters to be
considered in the operation at hand. The roster of function names in the C
<B>char</B> array handling library literally runs to several pages, and though
the kind and number of arguments to the functions are somewhat consistent within
each of the three groups, to use them properly you must be very attentive to
details of function naming and parameter passing.<BR></P></DIV>
<DIV ALIGN="LEFT"><P>The second inherent trap of the standard C <B>char</B> array
tools is that they all rely explicitly on the assumption that the character
array includes a null terminator. If by oversight or error the null is omitted
or overwritten, there&#8217;s very little to keep the C <B>char</B> array
handling functions from manipulating the memory beyond the limits of the
allocated space, sometimes with disastrous results. <BR></P></DIV>
<DIV ALIGN="LEFT"><P>C++ provides a vast improvement in the convenience and safety
of <B>string</B> objects. For purposes of actual string handling operations,
there are a modest two or three dozen member function names. It&#8217;s worth
your while to become acquainted with these. Each function is overloaded, so you
don&#8217;t have to learn a new <B>string</B> member function name simply
because of small differences in their
parameters.<A NAME="_Toc462393370"></A><BR></P></DIV>
<A NAME="Heading26"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Appending, inserting and concatenating strings</H3></FONT>
<DIV ALIGN="LEFT"><P>One of the most valuable and convenient aspects of C++ strings
is that they grow as needed, without intervention on the part of the programmer.
Not only does this make string handling code inherently more trustworthy, it
also almost entirely eliminates a tedious &#8220;housekeeping&#8221; chore
&#8211; keeping track of the bounds of the storage in which your strings live.
For example, if you create a string object and initialize it with a string of 50
copies of &#8216;X&#8217;, and later store in it 50 copies of
&#8220;Zowie&#8221;, the object itself will reallocate sufficient storage to
accommodate the growth of the data. Perhaps nowhere is this property more
appreciated than when the strings manipulated in your code change in size, and
you don&#8217;t know how big the change is. Appending, concatenating, and
inserting strings often give rise to this circumstance, but the string member
functions <B>append(&#160;)</B> and <B>insert(&#160;)</B> transparently
reallocate storage when a string grows.<BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C01:StrSize.cpp</font>
#include &lt;string&gt;
#include &lt;iostream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main() {
  string bigNews(<font color=#004488>"I saw Elvis in a UFO. "</font>);
  cout &lt;&lt; bigNews &lt;&lt; endl;
  <font color=#009900>// How much data have we actually got?</font>
  cout &lt;&lt; <font color=#004488>"Size = "</font> &lt;&lt; bigNews.size() &lt;&lt; endl;
  <font color=#009900>// How much can we store without reallocating</font>
  cout &lt;&lt; <font color=#004488>"Capacity = "</font> 
    &lt;&lt; bigNews.capacity() &lt;&lt; endl;
  <font color=#009900>// Insert this string in bigNews immediately</font>
  <font color=#009900>// before bigNews[1]</font>
  bigNews.insert(1, <font color=#004488>" thought I "</font>);
  cout &lt;&lt; bigNews &lt;&lt; endl;
  cout &lt;&lt; <font color=#004488>"Size = "</font> &lt;&lt; bigNews.size() &lt;&lt; endl;
  cout &lt;&lt; <font color=#004488>"Capacity = "</font> 
    &lt;&lt; bigNews.capacity() &lt;&lt; endl;
  <font color=#009900>// Make sure that there will be this much space</font>
  bigNews.reserve(500);
  <font color=#009900>// Add this to the end of the string</font>
  bigNews.append(<font color=#004488>"I've been working too hard."</font>);
  cout &lt;&lt; bigNews &lt;&lt; endl;
  cout &lt;&lt; <font color=#004488>"Size = "</font> &lt;&lt; bigNews.size() &lt;&lt; endl;
  cout &lt;&lt; <font color=#004488>"Capacity = "</font> 
    &lt;&lt; bigNews.capacity() &lt;&lt; endl;</PRE></FONT></BLOCKQUOTE><DIV ALIGN="LEFT"><P><TT><FONT FACE="Courier New">}
///:~</FONT></TT><BR></P></DIV>

<DIV ALIGN="LEFT"><P>Here is the output:<BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>I saw Elvis in a UFO.
Size = 21
Capacity = 31
I thought I saw Elvis in a UFO.
Size = 32
Capacity = 63
I thought I saw Elvis in a UFO. I've been 
working too hard.
Size = 66</PRE></FONT></BLOCKQUOTE><DIV ALIGN="LEFT"><P><TT><FONT FACE="Courier New">Capacity =
511</FONT></TT><BR></P></DIV>

<DIV ALIGN="LEFT"><P>This example demonstrates that even though you can safely
relinquish much of the responsibility for allocating and managing the memory
your <B>string</B>s occupy, C++ <B>string</B>s provide you with several tools to
monitor and manage their size. The <B>size(&#160;)</B>, <B>resize(&#160;)</B>,
<B>capacity(&#160;)</B>, and <B>reserve(&#160;)</B> member functions can be very
useful when its necessary to work back and forth between data contained in C++
style strings and traditional null terminated C <B>char</B> arrays. Note the
ease with which we changed the size of the storage allocated to the
string.<BR></P></DIV>
<DIV ALIGN="LEFT"><P>The exact fashion in which the <B>string</B> member functions
will allocate space for your data is dependent on the implementation of the
library. When one implementation was tested with the example above, it appeared
that reallocations occurred on even word boundaries, with one byte held back.
The architects of the <B>string</B> class have endeavored to make it possible to
mix the use of C <B>char</B> arrays and C++ string objects, so it is likely that
figures reported by <B>StrSize.cpp</B> for capacity reflect that in this
particular implementation, a byte is set aside to easily accommodate the
insertion of a null terminator. <A NAME="_Toc462393371"></A><BR></P></DIV>
<A NAME="Heading27"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Replacing string characters</H3></FONT>
<DIV ALIGN="LEFT"><P><B>insert(&#160;) </B>is particularly nice because it absolves
you of making sure the insertion of characters in a string won&#8217;t overrun
the storage space or overwrite the characters immediately following the
insertion point. Space grows and existing characters politely move over to
accommodate the new elements. Sometimes, however, this might not be what you
want to happen. If the data in string needs to retain the ordering of the
original characters relative to one another or must be a specific constant size,
use the <B>replace(&#160;)</B> function to overwrite a particular sequence of
characters with another group of characters. There are quite a number of
overloaded versions of <B>replace(&#160;)</B>, but the simplest one takes three
arguments: an integer telling where to start in the string, an integer telling
how many characters to eliminate from the original string, and the replacement
string (which can be a different number of characters than the eliminated
quantity). Here&#8217;s a very simple example:<BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C01:StringReplace.cpp</font>
<font color=#009900>// Simple find-and-replace in strings</font>
#include &lt;string&gt;
#include &lt;iostream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main() {
  string s(<font color=#004488>"A piece of text"</font>);
  string tag(<font color=#004488>"$tag$"</font>);
  s.insert(8, tag + ' ');
  cout &lt;&lt; s &lt;&lt; endl;
  <font color=#0000ff>int</font> start = s.find(tag);
  cout &lt;&lt; <font color=#004488>"start = "</font> &lt;&lt; start &lt;&lt; endl;
  cout &lt;&lt; <font color=#004488>"size = "</font> &lt;&lt; tag.size() &lt;&lt; endl;
  s.replace(start, tag.size(), <font color=#004488>"hello there"</font>);
  cout &lt;&lt; s &lt;&lt; endl;</PRE></FONT></BLOCKQUOTE><DIV ALIGN="LEFT"><P><TT><FONT FACE="Courier New">}
///:~</FONT></TT><BR></P></DIV>

<DIV ALIGN="LEFT"><P>The <B>tag</B> is first inserted into <B>s</B> (notice that
the insert happens <I>before</I> the value indicating the insert point, and that
an extra space was added after <B>tag</B>), then it is found and
replaced.<BR></P></DIV>
<DIV ALIGN="LEFT"><P>You should actually check to see if you&#8217;ve found
anything before you perform a <B>replace(&#160;)</B>.<B> </B>The above example
replaces with a <B>char*</B>, but there&#8217;s an overloaded version that
replaces with a <B>string</B>.<B> </B>Here&#8217;s a more complete demonstration
<B>replace(&#160;)</B><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C01:Replace.cpp</font>
#include &lt;string&gt;
#include &lt;iostream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>void</font> replaceChars(string&amp; modifyMe, 
  string findMe, string newChars){
  <font color=#009900>// Look in modifyMe for the "find string"</font>
  <font color=#009900>// starting at position 0</font>
  <font color=#0000ff>int</font> i = modifyMe.find(findMe, 0);
  <font color=#009900>// Did we find the string to replace?</font>
  <font color=#0000ff>if</font>(i != string::npos)
    <font color=#009900>// Replace the find string with newChars</font>
    modifyMe.replace(i,newChars.size(),newChars);
}

<font color=#0000ff>int</font> main() {
  string bigNews = 
   <font color=#004488>"I thought I saw Elvis in a UFO. "</font>
   <font color=#004488>"I have been working too hard."</font>;
  string replacement(<font color=#004488>"wig"</font>);
  string findMe(<font color=#004488>"UFO"</font>);
  <font color=#009900>// Find "UFO" in bigNews and overwrite it:</font>
  replaceChars(bigNews, findMe,  replacement);
  cout &lt;&lt; bigNews &lt;&lt; endl;</PRE></FONT></BLOCKQUOTE><DIV ALIGN="LEFT"><P><TT><FONT FACE="Courier New">}
///:~</FONT></TT><BR></P></DIV>

<DIV ALIGN="LEFT"><P>Now the last line of output from <B>replace.cpp</B> looks like
this:<BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>I thought I saw Elvis in a wig. I have been</PRE></FONT></BLOCKQUOTE><DIV ALIGN="LEFT"><P><TT><FONT FACE="Courier New">working
too hard.</FONT></TT><BR></P></DIV>

<DIV ALIGN="LEFT"><P>If replace doesn&#8217;t find the search string, it returns
<B>npos</B>. <B>npos</B> is a static constant member of the <B>basic_string</B>
class.<BR></P></DIV>
<DIV ALIGN="LEFT"><P>Unlike <B>insert(&#160;)</B>, <B>replace(&#160;)</B>
won&#8217;t grow the <B>string</B>&#8217;s storage space if you copy new
characters into the middle of an existing series of array elements. However, it
<I>will</I> grow the storage space if you make a &#8220;replacement&#8221; that
writes beyond the end of an existing array. Here&#8217;s an example:<BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C01:ReplaceAndGrow.cpp</font>
#include &lt;string&gt;
#include &lt;iostream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main() {
  string bigNews(<font color=#004488>"I saw Elvis in a UFO. "</font>
    <font color=#004488>"I have been working too hard."</font>);
  string replacement(<font color=#004488>"wig"</font>);
  <font color=#009900>// The first arg says "replace chars </font>
  <font color=#009900>// beyond the end of the existing string":</font>
  bigNews.replace(bigNews.size(), 
    replacement.size(), replacement);
  cout &lt;&lt; bigNews &lt;&lt; endl;</PRE></FONT></BLOCKQUOTE><DIV ALIGN="LEFT"><P><TT><FONT FACE="Courier New">}
///:~</FONT></TT><BR></P></DIV>

<DIV ALIGN="LEFT"><P>The call to <B>replace(&#160;) </B>begins
&#8220;replacing&#8221; beyond the end of the existing array. The output looks
like this:<BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>I saw Elvis in a UFO. I have </PRE></FONT></BLOCKQUOTE><DIV ALIGN="LEFT"><P><TT><FONT FACE="Courier New">been
working too hard.wig</FONT></TT><BR></P></DIV>

<DIV ALIGN="LEFT"><P>Notice that <B>replace(&#160;)</B> expands the array to
accommodate the growth of the string due to &#8220;replacement&#8221; beyond the
bounds of the existing array.<BR></P></DIV>
<A NAME="Heading28"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Simple character replacement using the STL replace(&#160;) algorithm</H4></FONT>
<DIV ALIGN="LEFT"><P>You may have been hunting through this chapter trying to do
something relatively simple like replace all the instances of one character with
a different character. Upon finding the above section on replacing, you thought
you found the answer but then you started seeing groups of characters and counts
and other things that looked a bit too complex. Doesn&#8217;t <B>string</B> have
a way to just replace one character with another everywhere?<BR></P></DIV>
<DIV ALIGN="LEFT"><P>The <B>string</B> class by itself doesn&#8217;t solve all
possible problems. The remainder are relegated to the STL algorithms, because
the <B>string</B> class can look just like an STL container (the STL algorithms
work with anything that looks like an STL container). All the STL algorithms
work on a &#8220;range&#8221; of elements within a container. Usually that range
is just &#8220;from the beginning of the container to the end.&#8221; A
<B>string</B> object looks like a container of characters: to get the beginning
of the range you use <B>string::begin(&#160;)</B> and to get the end of the
range you use <B>string::end(&#160;)</B>. The following example shows the use of
the STL <B>replace(&#160;)</B> algorithm to replace all the instances of
&#8216;X&#8217; with &#8216;Y&#8217;:<BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C01:StringCharReplace.cpp</font>
#include &lt;string&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main() {
  string s(<font color=#004488>"aaaXaaaXXaaXXXaXXXXaaa"</font>);
  cout &lt;&lt; s &lt;&lt; endl;
  replace(s.begin(), s.end(), 'X', 'Y');
  cout &lt;&lt; s &lt;&lt; endl;</PRE></FONT></BLOCKQUOTE><DIV ALIGN="LEFT"><P><TT><FONT FACE="Courier New">}
///:~</FONT></TT><BR></P></DIV>

<DIV ALIGN="LEFT"><P>Notice that this <B>replace(&#160;)</B> is <I>not</I> called
as a member function of <B>string</B>. Also, unlike the
<B>string::replace(&#160;)</B> functions which only perform one replacement, the
STL replace is replacing all instances of one character with another.<BR></P></DIV>
<DIV ALIGN="LEFT"><P>The STL <B>replace(&#160;)</B> algorithm only works with
single objects (in this case, <B>char</B> objects), and will not perform
replacements of quoted <B>char</B> arrays or of <B>string</B> objects.<BR></P></DIV>
<DIV ALIGN="LEFT"><P>Since a <B>string</B> looks like an STL container, there are a
number of other STL algorithms that can be applied to it, which may solve other
problems you have that are not directly addressed by the <B>string</B> member
functions. See Chapter XX for more information on the STL
algorithms.<A NAME="_Toc462393372"></A><BR></P></DIV>
<A NAME="Heading29"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Concatenation using non-member overloaded operators</H3></FONT>
<DIV ALIGN="LEFT"><P>One of the most delightful discoveries awaiting a C programmer
learning about C++ <B>string</B> handling is how simply <B>string</B>s can be
combined and appended using <B>operator+</B> and <B>operator+=</B>.<B> </B>These
operators make combining <B>string</B>s syntactically equivalent to adding
numeric data.<BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C01:AddStrings.cpp</font>
#include &lt;string&gt;
#include &lt;iostream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main() {
  string s1(<font color=#004488>"This "</font>);
  string s2(<font color=#004488>"That "</font>);
  string s3(<font color=#004488>"The other "</font>);
  <font color=#009900>// operator+ concatenates strings</font>
  s1 = s1 + s2;
  cout &lt;&lt; s1 &lt;&lt; endl;
  <font color=#009900>// Another way to concatenates strings</font>
  s1 += s3;
  cout &lt;&lt; s1 &lt;&lt; endl;
  <font color=#009900>// You can index the string on the right</font>
  s1 += s3 + s3[4] + <font color=#004488>"oh lala"</font>;
  cout &lt;&lt; s1 &lt;&lt; endl;</PRE></FONT></BLOCKQUOTE><DIV ALIGN="LEFT"><P><TT><FONT FACE="Courier New">}
///:~</FONT></TT><BR></P></DIV>

<DIV ALIGN="LEFT"><P>The output looks like this:<BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>This
This That
This That The other</PRE></FONT></BLOCKQUOTE><DIV ALIGN="LEFT"><P><TT><FONT FACE="Courier New">This
That The other ooh lala</FONT></TT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><B>operator+</B> and <B>operator+= </B>are a very flexible
and<B> </B>convenient means of combining <B>string</B> data. On the right hand
side of the statement, you can use almost any type that evaluates to a group of
one or more characters. <A NAME="_Toc462393373"></A><BR></P></DIV>
<A NAME="Heading30"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Searching in strings</H2></FONT>
<DIV ALIGN="LEFT"><P>The <B>find</B> family of <B>string</B> member functions
allows you to locate a character or group of characters within a given string.
Here are the members of the <B>find</B> family and their general
usage:<BR></P></DIV>
<DIV ALIGN="LEFT"><P><TABLE BORDER>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><B>string find member function</B><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><B>What/how it finds </B><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><B> find(&#160;)</B><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P>Searches a string for a specified character or group of
characters and returns the starting position of the first occurrence found or
<B>npos</B> if no match is found. (<B>npos </B>is a const of &#8211;1 and
indicates that a search failed.) <BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><B> find_first_of(&#160;)</B><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P>Searches a target string and returns the position of the first
match of <I>any</I> character in a specified group. If no match is found, it
returns <B>npos</B>.<BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><B> find_last_of(&#160;)</B><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P>Searches a target string and returns the position of the last
match of <I>any</I> character in a specified group. If no match is found, it
returns <B>npos</B>.<BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><B> find_first_not_of(&#160;)</B><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P>Searches a target string and returns the position of the first
element that <I>doesn&#8217;t</I> match <I>any</I> character in a specified
group. If no such element is found, it returns <B>npos</B>.<BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><B> find_last_not_of(&#160;)</B><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P>Searches a target string and returns the position of the
element with the largest subscript that <I>doesn&#8217;t</I> match of <I>any</I>
character in a specified group. If no such element is found, it returns
<B>npos</B>.<BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><B> rfind(&#160;)</B><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P>Searches a string from end to beginning for a specified
character or group of characters and returns the starting position of the match
if one is found. If no match is found, it returns <B>npos</B>.<BR></P></DIV>
</TD>
</TR>
</TABLE></P></DIV>
<DIV ALIGN="LEFT"><P><B>String searching member functions and their general
uses</B><BR></P></DIV>
<DIV ALIGN="LEFT"><P>The simplest use of <B>find(&#160;) </B>searches for one or
more characters in a <B>string</B>. This overloaded version of <B>find(&#160;)
</B>takes a parameter that specifies the character(s) for which to search, and
optionally one that tells it where in the string to begin searching for the
occurrence of a substring. (The default position at which to begin searching is
0.) By setting the call to <B>find </B>inside a loop, you can easily move
through a string, repeating a search in order to find all of the occurrences of
a given character or group of characters within the string. <BR></P></DIV>
<DIV ALIGN="LEFT"><P>Notice that we define the string object <B>sieveChars</B>
using a constructor idiom which sets the initial size of the character array and
writes the value &#8216;P&#8217; to each of its member.<BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C01:Sieve.cpp</font>
#include &lt;string&gt;
#include &lt;iostream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main() {
  <font color=#009900>// Create a 50 char string and set each </font>
  <font color=#009900>// element to 'P' for Prime</font>
  string sieveChars(50, 'P');
  <font color=#009900>// By definition neither 0 nor 1 is prime.</font>
  <font color=#009900>// Change these elements to "N" for Not Prime</font>
  sieveChars.replace(0, 2, <font color=#004488>"NN"</font>);
  <font color=#009900>// Walk through the array:</font>
  <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 2;  
    i &lt;= (sieveChars.size() / 2) - 1; i++)
    <font color=#009900>// Find all the factors:</font>
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> factor = 2;
      factor * i &lt; sieveChars.size();factor++)
      sieveChars[factor * i] = 'N';
     
  cout &lt;&lt; <font color=#004488>"Prime:"</font> &lt;&lt; endl;
  <font color=#009900>// Return the index of the first 'P' element:</font>
  <font color=#0000ff>int</font> j = sieveChars.find('P');
  <font color=#009900>// While not at the end of the string:</font>
  <font color=#0000ff>while</font>(j != sieveChars.npos) {
    <font color=#009900>// If the element is P, the index is a prime</font>
    cout &lt;&lt; j &lt;&lt; <font color=#004488>" "</font>;
    <font color=#009900>// Move past the last prime</font>
    j++;
    <font color=#009900>// Find the next prime</font>
    j = sieveChars.find('P', j);
  }
  cout &lt;&lt; <font color=#004488>"\n Not prime:"</font> &lt;&lt; endl;
  <font color=#009900>// Find the first element value not equal P:</font>
  j = sieveChars.find_first_not_of('P');
  <font color=#0000ff>while</font>(j != sieveChars.npos) {
    cout &lt;&lt; j &lt;&lt; <font color=#004488>" "</font>;
    j++;
    j = sieveChars.find_first_not_of('P', j);
  }</PRE></FONT></BLOCKQUOTE><DIV ALIGN="LEFT"><P><TT><FONT FACE="Courier New">}
///:~</FONT></TT><BR></P></DIV>

<DIV ALIGN="LEFT"><P>The output from <B>Sieve.cpp</B> looks like this:<BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>Prime:
2 3 5 7 11 13 17 19 23 29 31 37 41 43 47
Not prime:
0 1 4 6 8 9 10 12 14 15 16 18 20 21 22 
24 25 26 27 28 30 32 33 34 35 36 38 39 
40 42 44 45 46 48 49</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><B>find(&#160;)</B> allows you to walk forward through a
<B>string</B>, detecting multiple occurrences of a character or group of
characters, while <B>find_first_not_of(&#160;)</B> allows you to test for the
absence of a character or group.<BR></P></DIV>
<DIV ALIGN="LEFT"><P>The <B>find</B> member is also useful for detecting the
occurrence of a sequence of characters in a <B>string</B>:<BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C01:Find.cpp</font>
<font color=#009900>// Find a group of characters in a string</font>
#include &lt;string&gt;
#include &lt;iostream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main() {
  string chooseOne(<font color=#004488>"Eenie, meenie, miney, mo"</font>);
  <font color=#0000ff>int</font> i = chooseOne.find(<font color=#004488>"een"</font>);
  <font color=#0000ff>while</font>(i != string::npos) {
    cout &lt;&lt; i &lt;&lt; endl;
    i++;
    i = chooseOne.find(<font color=#004488>"een"</font>, i);
  }</PRE></FONT></BLOCKQUOTE><DIV ALIGN="LEFT"><P><TT><FONT FACE="Courier New">}
///:~</FONT></TT><BR></P></DIV>

<DIV ALIGN="LEFT"><P><B>Find.cpp</B> produces a single line of output :<BR></P></DIV>
<DIV ALIGN="LEFT"><P><TT><FONT FACE="Courier New"> 8 </FONT></TT><BR></P></DIV>

<DIV ALIGN="LEFT"><P>This tells us that the first &#8216;e&#8217; of the search
group &#8220;een&#8221; was found in the word &#8220;meenie,&#8221; and is the
eighth element in the string. Notice that <B>find</B> passed over the
&#8220;Een&#8221; group of characters in the word &#8220;Eenie&#8221;. The
<B>find</B> member function performs a <I>case sensitive</I> search. <BR></P></DIV>
<DIV ALIGN="LEFT"><P>There are no functions in the <B>string </B>class to change
the case of a string, but these functions can be easily created using the
Standard C library functions <B>toupper(&#160;)</B> and <B>tolower(&#160;)</B>,
which change the case of one character at a time. A few small changes will make
<B>Find.cpp</B> perform a case insensitive search:<BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C01:NewFind.cpp</font>
#include &lt;string&gt;
#include &lt;iostream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#009900>// Make an uppercase copy of s:</font>
string upperCase(string&amp; s) {
  <font color=#0000ff>char</font>* buf = <font color=#0000ff>new</font> <font color=#0000ff>char</font>[s.length()];
  s.copy(buf, s.length());
  <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; s.length(); i++)
    buf[i] = toupper(buf[i]);
  string r(buf, s.length());
  <font color=#0000ff>delete</font> buf;
  <font color=#0000ff>return</font> r;
}

<font color=#009900>// Make a lowercase copy of s:</font>
string lowerCase(string&amp; s) {
  <font color=#0000ff>char</font>* buf = <font color=#0000ff>new</font> <font color=#0000ff>char</font>[s.length()];
  s.copy(buf, s.length());
  <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; s.length(); i++)
    buf[i] = tolower(buf[i]);
  string r(buf, s.length());
  <font color=#0000ff>delete</font> buf;
  <font color=#0000ff>return</font> r;
}

<font color=#0000ff>int</font> main() {
  string chooseOne(<font color=#004488>"Eenie, meenie, miney, mo"</font>);
  cout &lt;&lt; chooseOne &lt;&lt; endl;
  cout &lt;&lt; upperCase(chooseOne) &lt;&lt; endl;
  cout &lt;&lt; lowerCase(chooseOne) &lt;&lt; endl;
  <font color=#009900>// Case sensitive search</font>
  <font color=#0000ff>int</font> i = chooseOne.find(<font color=#004488>"een"</font>);
  <font color=#0000ff>while</font>(i != string::npos) {
    cout &lt;&lt; i &lt;&lt; endl;
    i++;
    i = chooseOne.find(<font color=#004488>"een"</font>, i);
  }
  <font color=#009900>// Search lowercase:</font>
  string lcase = lowerCase(chooseOne);
  cout &lt;&lt; lcase &lt;&lt; endl;
  i = lcase.find(<font color=#004488>"een"</font>);
  <font color=#0000ff>while</font>(i != lcase.npos) {
    cout &lt;&lt; i &lt;&lt; endl;
    i++;
    i = lcase.find(<font color=#004488>"een"</font>, i);
  }
  <font color=#009900>// Search uppercase:</font>
  string ucase = upperCase(chooseOne);
  cout &lt;&lt; ucase &lt;&lt; endl;
  i = ucase.find(<font color=#004488>"EEN"</font>);
  <font color=#0000ff>while</font>(i != ucase.npos) {
    cout &lt;&lt; i &lt;&lt; endl;
    i++;
    i = ucase.find(<font color=#004488>"EEN"</font>, i);
  }</PRE></FONT></BLOCKQUOTE><DIV ALIGN="LEFT"><P><TT><FONT FACE="Courier New">}
///:~</FONT></TT><BR></P></DIV>

<DIV ALIGN="LEFT"><P>Both the <B>upperCase(&#160;)</B> and <B>lowerCase(&#160;)</B>
functions follow the same form: they allocate storage to hold the data in the
argument <B>string</B>, copy the data and change the case. Then they create a
new <B>string</B> with the new data, release the buffer and return the result
<B>string</B>. The <B>c_str(&#160;)</B> function cannot be used to produce a
pointer to directly manipulate the data in the <B>string</B> because
<B>c_str(&#160;)</B> returns a pointer to <B>const</B>. That is, you&#8217;re
not allowed to manipulate <B>string</B> data with a pointer, only with member
functions. If you need to use the more primitive <B>char</B> array manipulation,
you should use the technique shown above.<BR></P></DIV>
<DIV ALIGN="LEFT"><P>The output looks like this:<BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>Eenie, meenie, miney, mo
EENIE, MEENIE, MINEY, MO
eenie, meenie, miney, mo
8
eenie, meenie, miney, mo
0
8
EENIE, MEENIE, MINEY, MO
0</PRE></FONT></BLOCKQUOTE><DIV ALIGN="LEFT"><P><TT><FONT FACE="Courier New">8</FONT></TT><BR></P></DIV>

<DIV ALIGN="LEFT"><P>The case insensitive searches found both occurrences on the
&#8220;een&#8221; group. <BR></P></DIV>
<DIV ALIGN="LEFT"><P><B>NewFind.cpp</B> isn&#8217;t the best solution to the case
sensitivity problem, so we&#8217;ll revisit it when we examine <B>string</B>
comparisons.<A NAME="_Toc462393374"></A><BR></P></DIV>
<A NAME="Heading31"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Finding in reverse</H3></FONT>
<DIV ALIGN="LEFT"><P>Sometimes it&#8217;s necessary to search through a
<B>string</B> from end to beginning, if you need to find the data in &#8220;last
in / first out &#8220; order. The string member function <B>rfind(&#160;)</B>
handles this job. <BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C01:Rparse.cpp</font>
<font color=#009900>// Reverse the order of words in a string</font>
#include &lt;string&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main() {
  <font color=#009900>// The ';' characters will be delimiters</font>
  string s(<font color=#004488>"now.;sense;make;to;going;is;This"</font>);
  cout &lt;&lt; s &lt;&lt; endl;
  <font color=#009900>// To store the words:</font>
  vector&lt;string&gt; strings;
  <font color=#009900>// The last element of the string:</font>
  <font color=#0000ff>int</font> last = s.size();
  <font color=#009900>// The beginning of the current word:</font>
  <font color=#0000ff>int</font> current = s.rfind(';');
  <font color=#009900>// Walk backward through the string:</font>
  <font color=#0000ff>while</font>(current != string::npos){
    <font color=#009900>// Push each word into the vector.</font>
    <font color=#009900>// Current is incremented before copying to </font>
    <font color=#009900>// avoid copying the delimiter.</font>
    strings.push_back(
      s.substr(++current,last - current));
    <font color=#009900>// Back over the delimiter we just found, </font>
    <font color=#009900>// and set last to the end of the next word</font>
    current -= 2;
    last = current;
    <font color=#009900>// Find the next delimiter</font>
    current = s.rfind(';', current);
  }
  <font color=#009900>// Pick up the first word - it's not </font>
  <font color=#009900>// preceded by a delimiter</font>
  strings.push_back(s.substr(0, last - current));
  <font color=#009900>// Print them in the new order:</font>
  <font color=#0000ff>for</font>(<font color=#0000ff>int</font> j = 0; j &lt; strings.size(); j++)
    cout &lt;&lt; strings[j] &lt;&lt; <font color=#004488>" "</font>;</PRE></FONT></BLOCKQUOTE><DIV ALIGN="LEFT"><P><TT><FONT FACE="Courier New">}
///:~</FONT></TT><BR></P></DIV>

<DIV ALIGN="LEFT"><P>Here&#8217;s how the output from <B>Rparse.cpp</B>
looks:<BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>now.;sense;make;to;going;is;This</PRE></FONT></BLOCKQUOTE><DIV ALIGN="LEFT"><P><TT><FONT FACE="Courier New">This
is going to make sense now.</FONT></TT><BR></P></DIV>

<DIV ALIGN="LEFT"><P><B>rfind(&#160;)</B> backs through the string looking for
tokens, reporting the array index of matching characters or <B>string::npos</B>
if it is unsuccessful. <A NAME="_Toc462393375"></A><BR></P></DIV>
<A NAME="Heading32"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Finding first/last of a set</H3></FONT>
<DIV ALIGN="LEFT"><P>The <B>find_first_of(&#160;)</B> and
<B>find_last_of(&#160;)</B> member functions can be conveniently put to work to
create a little utility that will strip whitespace characters off of both ends
of a string. Notice it doesn&#8217;t touch the original string, but instead
returns a new string:<BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C01:trim.h</font>
#ifndef TRIM_H
#define TRIM_H
#include &lt;string&gt;
<font color=#009900>// General tool to strip spaces from both ends:</font>
<font color=#0000ff>inline</font> std::string trim(<font color=#0000ff>const</font> std::string&amp; s) {
  <font color=#0000ff>if</font>(s.length() == 0)
    <font color=#0000ff>return</font> s;
  <font color=#0000ff>int</font> b = s.find_first_not_of(<font color=#004488>" \t"</font>);
  <font color=#0000ff>int</font> e = s.find_last_not_of(<font color=#004488>" \t"</font>);
  <font color=#0000ff>if</font>(b == -1) <font color=#009900>// No non-spaces</font>
    <font color=#0000ff>return</font> <font color=#004488>""</font>;
  <font color=#0000ff>return</font> std::string(s, b, e - b + 1);
}</PRE></FONT></BLOCKQUOTE><DIV ALIGN="LEFT"><P><TT><FONT FACE="Courier New">#endif // TRIM_H
///:~</FONT></TT><BR></P></DIV>

<DIV ALIGN="LEFT"><P>The first test checks for an empty <B>string</B>; in that case
no tests are made and a copy is returned. Notice that once the end points are
found, the <B>string</B> constructor is used to build a new <B>string</B> from
the old one, giving the starting count and the length. This form also utilizes
the &#8220;return value optimization&#8221; (see the index for more
details).<BR></P></DIV>
<DIV ALIGN="LEFT"><P>Testing such a general-purpose tool needs to be
thorough:<BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C01:TrimTest.cpp</font>
#include <font color=#004488>"trim.h"</font>
#include &lt;iostream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

string s[] = {
  <font color=#004488>" \t abcdefghijklmnop \t "</font>,
  <font color=#004488>"abcdefghijklmnop \t "</font>,
  <font color=#004488>" \t abcdefghijklmnop"</font>,
  <font color=#004488>"a"</font>, <font color=#004488>"ab"</font>, <font color=#004488>"abc"</font>, <font color=#004488>"a b c"</font>,
  <font color=#004488>" \t a b c \t "</font>, <font color=#004488>" \t a \t b \t c \t "</font>,
  <font color=#004488>""</font>, <font color=#009900>// Must also test the empty string</font>
};

<font color=#0000ff>void</font> test(string s) {
  cout &lt;&lt; <font color=#004488>"["</font> &lt;&lt; trim(s) &lt;&lt; <font color=#004488>"]"</font> &lt;&lt; endl;
}

<font color=#0000ff>int</font> main() {
  <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; <font color=#0000ff>sizeof</font> s / <font color=#0000ff>sizeof</font> *s; i++)
    test(s[i]);</PRE></FONT></BLOCKQUOTE><DIV ALIGN="LEFT"><P><TT><FONT FACE="Courier New">}
///:~</FONT></TT><BR></P></DIV>

<DIV ALIGN="LEFT"><P>In the array of <B>string</B> <B>s</B>, you can see that the
character arrays are automatically converted to <B>string</B> objects. This
array provides cases to check the removal of spaces and tabs from both ends, as
well as ensuring that spaces and tabs do not get removed from the middle of a
<B>string</B>.<A NAME="_Toc462393376"></A><BR></P></DIV>
<A NAME="Heading33"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Removing characters from strings</H3></FONT>
<DIV ALIGN="LEFT"><P>My word processor/page layout program (Microsoft Word) will
save a document in HTML, but it doesn&#8217;t recognize that the code listings
in this book should be tagged with the HTML &#8220;preformatted&#8221; tag
(&lt;PRE&gt;), and it puts paragraph marks (&lt;P&gt; and &lt;/P&gt;) around
every listing line. This means that all the indentation in the code listings is
lost. In addition, Word saves HTML with reduced font sizes for body text, which
makes it hard to read.<BR></P></DIV>
<DIV ALIGN="LEFT"><P>To convert the book to HTML
form<A NAME="fnB5" HREF="#fn5">[5]</A>, then, the original output must be
reprocessed, watching for the tags that mark the start and end of code listings,
inserting the &lt;PRE&gt; and &lt;/PRE&gt; tags at the appropriate places,
removing all the &lt;P&gt; and &lt;/P&gt; tags within the listings, and
adjusting the font sizes. Removal is accomplished with the <B>erase(&#160;)</B>
member function, but you must correctly determine the starting and ending points
of the substring you wish to erase. Here&#8217;s the program that reprocesses
the generated HTML file:<BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C01:ReprocessHTML.cpp</font>
<font color=#009900>// Take Word's html output and fix up </font>
<font color=#009900>// the code listings and html tags</font>
#include <font color=#004488>"..</font><font color=#004488>/require.h"</font>
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;string&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#009900>// Produce a new string which is the original</font>
<font color=#009900>// string with the html paragraph break marks</font>
<font color=#009900>// stripped off:</font>
string stripPBreaks(string s) {
  <font color=#0000ff>int</font> br;
  <font color=#0000ff>while</font>((br = s.find(<font color=#004488>"&lt;P&gt;"</font>)) != string::npos)
    s.erase(br, strlen(<font color=#004488>"&lt;P&gt;"</font>));
  <font color=#0000ff>while</font>((br = s.find(<font color=#004488>"&lt;</font><font color=#004488>/P&gt;"</font>)) != string::npos)
    s.erase(br, strlen(<font color=#004488>"&lt;</font><font color=#004488>/P&gt;"</font>));
  <font color=#0000ff>return</font> s;
}

<font color=#009900>// After the beginning of a code listing is</font>
<font color=#009900>// detected, this function cleans up the listing</font>
<font color=#009900>// until the end marker is found. The first line</font>
<font color=#009900>// of the listing is passed in by the caller, </font>
<font color=#009900>// which detects the start marker in the line.</font>
<font color=#0000ff>void</font> fixupCodeListing(istream&amp; in, 
  ostream&amp; out, string&amp; line, <font color=#0000ff>int</font> tag) {
  out &lt;&lt; line.substr(0, tag)
    &lt;&lt; <font color=#004488>"&lt;PRE&gt;"</font> <font color=#009900>// Means "preformatted" in html</font>
    &lt;&lt; stripPBreaks(line.substr(tag)) &lt;&lt; endl;
  string s;
  <font color=#0000ff>while</font>(getline(in, s)) {
    <font color=#0000ff>int</font> endtag = s.find(<font color=#004488>"</font><font color=#004488>/"</font><font color=#004488>"</font><font color=#004488>/"</font><font color=#004488>"</font><font color=#004488>/"</font><font color=#004488>":~"</font>);
    <font color=#0000ff>if</font>(endtag != string::npos) {
      endtag += strlen(<font color=#004488>"</font><font color=#004488>/"</font><font color=#004488>"</font><font color=#004488>/"</font><font color=#004488>"</font><font color=#004488>/"</font><font color=#004488>":~"</font>);
      string before = s.substr(0, endtag);
      string after = s.substr(endtag);
      out &lt;&lt; stripPBreaks(before) &lt;&lt; <font color=#004488>"&lt;</font><font color=#004488>/PRE&gt;"</font> 
        &lt;&lt; after &lt;&lt; endl;
      <font color=#0000ff>return</font>;
    }
    out &lt;&lt; stripPBreaks(s) &lt;&lt; endl;
  }
}

string removals[] = {
  <font color=#004488>"&lt;FONT SIZE=2&gt;"</font>,
  <font color=#004488>"&lt;FONT SIZE=1&gt;"</font>,
  <font color=#004488>"&lt;FONT FACE=\"</font>Times\<font color=#004488>" SIZE=1&gt;"</font>,
  <font color=#004488>"&lt;FONT FACE=\"</font>Times\<font color=#004488>" SIZE=2&gt;"</font>,
  <font color=#004488>"&lt;FONT FACE=\"</font>Courier\<font color=#004488>" SIZE=1&gt;"</font>,
  <font color=#004488>"SIZE=1"</font>, <font color=#009900>// Eliminate all other '1' &amp; '2' size</font>
  <font color=#004488>"SIZE=2"</font>,
};
<font color=#0000ff>const</font> <font color=#0000ff>int</font> rmsz = 
  <font color=#0000ff>sizeof</font>(removals)/<font color=#0000ff>sizeof</font>(*removals);

<font color=#0000ff>int</font> main(<font color=#0000ff>int</font> argc, <font color=#0000ff>char</font>* argv[]) {
  requireArgs(argc, 2);
  ifstream in(argv[1]);
  assure(in, argv[1]);
  ofstream out(argv[2]);
  string line;
  <font color=#0000ff>while</font>(getline(in, line)) {
    <font color=#009900>// The "Body" tag only appears once:</font>
    <font color=#0000ff>if</font>(line.find(<font color=#004488>"&lt;BODY"</font>) != string::npos) {
      out &lt;&lt; <font color=#004488>"&lt;BODY BGCOLOR=\"</font>#FFFFFF\<font color=#004488>" "</font>
      <font color=#004488>"TEXT=\"</font>#000000\<font color=#004488>"&gt;"</font> &lt;&lt; endl;
      <font color=#0000ff>continue</font>; <font color=#009900>// Get next line</font>
    }
    <font color=#009900>// Eliminate each of the removals strings:</font>
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; rmsz; i++) {
      <font color=#0000ff>int</font> find = line.find(removals[i]);
      <font color=#0000ff>if</font>(find != string::npos)
        line.erase(find, removals[i].size());
    }
    <font color=#0000ff>int</font> tag1 = line.find(<font color=#004488>"</font><font color=#004488>/"</font><font color=#004488>"</font><font color=#004488>/"</font><font color=#004488>":"</font>);
    <font color=#0000ff>int</font> tag2 = line.find(<font color=#004488>"</font><font color=#004488>/"</font><font color=#004488>"*"</font><font color=#004488>":"</font>);
    <font color=#0000ff>if</font>(tag1 != string::npos)
      fixupCodeListing(in, out, line, tag1);
    <font color=#0000ff>else</font> <font color=#0000ff>if</font>(tag2 != string::npos)
      fixupCodeListing(in, out, line, tag2);
    <font color=#0000ff>else</font>
      out &lt;&lt; line &lt;&lt; endl;
  }</PRE></FONT></BLOCKQUOTE><DIV ALIGN="LEFT"><P><TT><FONT FACE="Courier New">}
///:~</FONT></TT><BR></P></DIV>

<DIV ALIGN="LEFT"><P>Notice the lines that detect the start and end listing tags by
indicating them with each character in quotes. These tags are treated in a
special way by the logic in the <B>Extractcode.cpp </B>tool for extracting code
listings. To present the code for the tool in the text of the book, the tag
sequence itself must not occur in the listing. This was accomplished by taking
advantage of a C++ preprocessor feature that causes text strings delimited by
adjacent pairs of double quotes to be merged into a single string during the
preprocessor pass of the build. <BR></P></DIV>
<DIV ALIGN="LEFT"><P><TT><FONT FACE="Courier New">int tag1 =
line.find("/""/"":");</FONT></TT><BR></P></DIV>

<DIV ALIGN="LEFT"><P>The effect of the sequence of <B>char</B> arrays is to produce
the starting tag for code listings.<BR></P></DIV>
<A NAME="Heading34"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Stripping HTML tags</H4></FONT>
<DIV ALIGN="LEFT"><P>Sometimes it&#8217;s useful to take an HTML file and strip its
tags so you have something approximating the text that would be displayed in the
Web browser, only as an ASCII text file. The <B>string</B> class once again
comes in handy. The following has some variation on the theme of the previous
example:<BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C01:HTMLStripper.cpp</font>
<font color=#009900>// Filter to remove html tags and markers</font>
#include <font color=#004488>"..</font><font color=#004488>/require.h"</font>
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

string replaceAll(string s, string f, string r) {
  <font color=#0000ff>unsigned</font> <font color=#0000ff>int</font> found = s.find(f);
  <font color=#0000ff>while</font>(found != string::npos) {
    s.replace(found, f.length(), r);
    found = s.find(f);
  }
  <font color=#0000ff>return</font> s;
}

string stripHTMLTags(string s) {
  <font color=#0000ff>while</font>(<font color=#0000ff>true</font>) {
    <font color=#0000ff>unsigned</font> <font color=#0000ff>int</font> left = s.find('&lt;');
    <font color=#0000ff>unsigned</font> <font color=#0000ff>int</font> right = s.find('&gt;');
    <font color=#0000ff>if</font>(left==string::npos || right==string::npos)
      <font color=#0000ff>break</font>;
    s = s.erase(left, right - left + 1);
  }
  s = replaceAll(s, <font color=#004488>"&amp;lt;"</font>, <font color=#004488>"&lt;"</font>);
  s = replaceAll(s, <font color=#004488>"&amp;gt;"</font>, <font color=#004488>"&gt;"</font>);
  s = replaceAll(s, <font color=#004488>"&amp;amp;"</font>, <font color=#004488>"&amp;"</font>);
  s = replaceAll(s, <font color=#004488>"&amp;nbsp;"</font>, <font color=#004488>" "</font>);
  <font color=#009900>// Etc...</font>
  <font color=#0000ff>return</font> s;
}

<font color=#0000ff>int</font> main(<font color=#0000ff>int</font> argc, <font color=#0000ff>char</font>* argv[]) {
  requireArgs(argc, 1, 
    <font color=#004488>"usage: HTMLStripper InputFile"</font>);
  ifstream in(argv[1]);
  assure(in, argv[1]);
  <font color=#0000ff>const</font> <font color=#0000ff>int</font> sz = 4096;
  <font color=#0000ff>char</font> buf[sz];
  <font color=#0000ff>while</font>(in.getline(buf, sz)) {
    string s(buf);
    cout &lt;&lt; stripHTMLTags(s) &lt;&lt; endl;
  }</PRE></FONT></BLOCKQUOTE><DIV ALIGN="LEFT"><P><TT><FONT FACE="Courier New">}
///:~</FONT></TT><BR></P></DIV>

<DIV ALIGN="LEFT"><P>The <B>string</B> class can replace one string with another
but there&#8217;s no facility for replacing all the strings of one type with
another, so the <B>replaceAll(&#160;)</B> function does this for you, inside a
<B>while</B> loop that keeps finding the next instance of the find string
<B>f</B>. That function is used inside <B>stripHTMLTags</B> after it uses
<B>erase(&#160;)</B> to remove everything that appears inside angle braces
(&#8216;<B>&lt;</B>&#8216; and &#8216;<B>&gt;</B>&#8216;). Note that I probably
haven&#8217;t gotten all the necessary replacement values, but you can see what
to do (you might even put all the find-replace pairs in a table...). In
<B>main(&#160;)</B> the arguments are checked, and the file is read and
converted. It is sent to standard output so you must redirect it with
&#8216;<B>&gt;</B>&#8216; if you want to write it to a
file.<A NAME="_Toc462393377"></A><BR></P></DIV>
<A NAME="Heading35"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Comparing strings </H3></FONT>
<DIV ALIGN="LEFT"><P>Comparing strings is inherently different than comparing
numbers. Numbers have constant, universally meaningful values. To evaluate the
relationship between the magnitude of two strings, you must make a <I>lexical
comparison</I>. Lexical comparison means that when you test a character to see
if it is &#8220;greater than&#8221; or &#8220;less than&#8221; another
character, you are actually comparing the numeric representation of those
characters as specified in the collating sequence of the character set being
used. Most often, this will be the ASCII collating sequence, which assigns the
printable characters for the English language numbers in the range from 32 to
127 decimal. In the ASCII collating sequence, the first &#8220;character&#8221;
in the list is the space, followed by several common punctuation marks, and then
uppercase and lowercase letters. With respect to the alphabet, this means that
the letters nearer the front have lower ASCII values than those nearer the end.
With these details in mind, it becomes easier to remember that when a lexical
comparison that reports s1 is &#8220;greater than&#8221; s2, it simply means
that when the two were compared, the first differing character in s1 came later
in the alphabet than the character in that same position in s2.<BR></P></DIV>
<DIV ALIGN="LEFT"><P>C++ provides several ways to compare strings, and each has
their advantages. The simplest to use are the non member overloaded operator
functions <B>operator ==, operator != operator &gt;, operator &lt;, operator
&gt;=, </B>and<B> operator &lt;=. </B><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C01:CompStr.cpp</font>
#include &lt;string&gt;
#include &lt;iostream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main() {
  <font color=#009900>// Strings to compare</font>
  string s1(<font color=#004488>"This "</font>);
  string s2(<font color=#004488>"That "</font>);
  <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i&lt; s1.size() &amp;&amp;
    i &lt; s2.size(); i++)
    <font color=#009900>// See if the string elements are the same:</font>
    <font color=#0000ff>if</font>(s1[i] == s2[i])
      cout &lt;&lt; s1[i] &lt;&lt; <font color=#004488>"  "</font> &lt;&lt; i &lt;&lt; endl;
  <font color=#009900>// Use the string inequality operators</font>
  <font color=#0000ff>if</font>(s1 != s2) { 
    cout &lt;&lt; <font color=#004488>"Strings aren't the same:"</font> &lt;&lt; <font color=#004488>" "</font>;
    <font color=#0000ff>if</font>(s1 &gt; s2)
      cout &lt;&lt; <font color=#004488>"s1 is &gt; s2"</font> &lt;&lt; endl;
    <font color=#0000ff>else</font>
      cout &lt;&lt; <font color=#004488>"s2 is &gt; s1"</font> &lt;&lt; endl;
  }</PRE></FONT></BLOCKQUOTE><DIV ALIGN="LEFT"><P><TT><FONT FACE="Courier New">}
///:~</FONT></TT><BR></P></DIV>

<DIV ALIGN="LEFT"><P>Here&#8217;s the output from <B>CompStr.cpp</B>:<BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>T 0
h 1
  4</PRE></FONT></BLOCKQUOTE><DIV ALIGN="LEFT"><P><TT><FONT FACE="Courier New">Strings aren&#8217;t the
same: s1 is &gt; s2 </FONT></TT><BR></P></DIV>

<DIV ALIGN="LEFT"><P>The overloaded comparison operators are useful for comparing
both full strings and individual string elements.<BR></P></DIV>
<DIV ALIGN="LEFT"><P>Notice in the code fragment below the flexibility of argument
types on both the left and right hand side of the comparison operators. The
overloaded operator set allows the direct comparison of string objects, quoted
literals, and pointers to C style strings. <BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>// The lvalue is a quoted literal and </font>
<font color=#009900>// the rvalue is a string</font>
<font color=#0000ff>if</font>(<font color=#004488>"That "</font> == s2)
  cout &lt;&lt; <font color=#004488>"A match"</font> &lt;&lt; endl;
<font color=#009900>// The lvalue is a string and the rvalue is a</font>
<font color=#009900>// pointer to a c style null terminated string</font>
<font color=#0000ff>if</font>(s1 != s2.c_str())</PRE></FONT></BLOCKQUOTE><DIV ALIGN="LEFT"><P><TT><FONT FACE="Courier New">  cout
&lt;&lt; "No match" &lt;&lt; endl;</FONT></TT><BR></P></DIV>

<DIV ALIGN="LEFT"><P>You won&#8217;t find the logical not (!) or the logical
comparison operators (&amp;&amp; and ||) among operators for string. (Neither
will you find overloaded versions of the bitwise C operators &amp;, |, ^, or ~.)
The overloaded non member comparison operators for the string class are limited
to the subset which has clear, unambiguous application to single characters or
groups of characters. <BR></P></DIV>
<DIV ALIGN="LEFT"><P>The <B>compare(&#160;)</B> member function offers you a great
deal more sophisticated and precise comparison than the non member operator set,
because it returns a lexical comparison value, and provides for comparisons that
consider subsets of the string data. It provides overloaded versions that allow
you to compare two complete strings, part of either string to a complete string,
and subsets of two strings. This example compares complete strings:<BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C01:Compare.cpp</font>
<font color=#009900>// Demonstrates compare(), swap()</font>
#include &lt;string&gt;
#include &lt;iostream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main() {
  string first(<font color=#004488>"This"</font>);
  string second(<font color=#004488>"That"</font>);
  <font color=#009900>// Which is lexically greater?</font>
  <font color=#0000ff>switch</font>(first.compare(second)) {
    <font color=#0000ff>case</font> 0: <font color=#009900>// The same</font>
      cout &lt;&lt; first &lt;&lt; <font color=#004488>" and "</font> &lt;&lt; second &lt;&lt;
        <font color=#004488>" are lexically equal"</font> &lt;&lt; endl;
      <font color=#0000ff>break</font>;
    <font color=#0000ff>case</font> -1: <font color=#009900>// Less than</font>
      first.swap(second);
      <font color=#009900>// Fall through this case...</font>
    <font color=#0000ff>case</font> 1: <font color=#009900>// Greater than</font>
      cout &lt;&lt; first &lt;&lt;
        <font color=#004488>" is lexically greater than "</font> &lt;&lt;
        second &lt;&lt; endl;
  }</PRE></FONT></BLOCKQUOTE><DIV ALIGN="LEFT"><P><TT><FONT FACE="Courier New">}
///:~</FONT></TT><BR></P></DIV>

<DIV ALIGN="LEFT"><P>The output from <B>Compare.cpp</B> looks like this:<BR></P></DIV>
<DIV ALIGN="LEFT"><P><TT><FONT FACE="Courier New">This is lexically greater than
That</FONT></TT><BR></P></DIV>

<DIV ALIGN="LEFT"><P>To compare a subset of the characters in one or both strings,
you add arguments that define where to start the comparison and how many
characters to consider. For example, we can use the overloaded version of
<B>compare(&#160;)</B>:<BR></P></DIV>
<DIV ALIGN="LEFT"><P><B>s1.compare(s1StartPos, s1NumberChars, s2, s2StartPos,
s2NumberChars);</B><BR></P></DIV>
<DIV ALIGN="LEFT"><P>If we substitute the above version of <B>compare(&#160;)</B>
in the previous program so that it only looks at the first two characters of
each string, the program becomes:<BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C01:Compare2.cpp</font>
<font color=#009900>// Overloaded compare()</font>
#include &lt;string&gt;
#include &lt;iostream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main() {
  string first(<font color=#004488>"This"</font>);
  string second(<font color=#004488>"That"</font>);
  <font color=#009900>// Compare first two characters of each string:</font>
  <font color=#0000ff>switch</font>(first.compare(0, 2, second, 0, 2)) {
    <font color=#0000ff>case</font> 0: <font color=#009900>// The same</font>
      cout &lt;&lt; first &lt;&lt; <font color=#004488>" and "</font> &lt;&lt; second &lt;&lt;
        <font color=#004488>" are lexically equal"</font> &lt;&lt; endl;
      <font color=#0000ff>break</font>;
    <font color=#0000ff>case</font> -1: <font color=#009900>// Less than</font>
      first.swap(second);
      <font color=#009900>// Fall through this case...</font>
    <font color=#0000ff>case</font> 1: <font color=#009900>// Greater than</font>
      cout &lt;&lt; first &lt;&lt;
        <font color=#004488>" is lexically greater than "</font> &lt;&lt;
        second &lt;&lt; endl;
  }</PRE></FONT></BLOCKQUOTE><DIV ALIGN="LEFT"><P><TT><FONT FACE="Courier New">}
///:~</FONT></TT><BR></P></DIV>

<DIV ALIGN="LEFT"><P>The output is:<BR></P></DIV>
<DIV ALIGN="LEFT"><P><TT><FONT FACE="Courier New">This and That are lexically
equal</FONT></TT><BR></P></DIV>

<DIV ALIGN="LEFT"><P>which is true, for the first two characters of
&#8220;This&#8221; and &#8220;That.&#8221;<BR></P></DIV>
<A NAME="Heading36"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Indexing with [ ] vs. at(&#160;)</H4></FONT>
<DIV ALIGN="LEFT"><P>In the examples so far, we have used C style array indexing
syntax to refer to an individual character in a string. C++ strings provide an
alternative to the <B>s[n] </B>notation: the <B>at(&#160;)</B> member. These two
idioms produce the same result in C++ if all goes well:<BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C01:StringIndexing.cpp</font>
#include &lt;string&gt;
#include &lt;iostream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;
<font color=#0000ff>int</font> main(){
  string s(<font color=#004488>"1234"</font>);
  cout &lt;&lt; s[1] &lt;&lt; <font color=#004488>" "</font>;
  cout &lt;&lt; s.at(1) &lt;&lt; endl;</PRE></FONT></BLOCKQUOTE><DIV ALIGN="LEFT"><P><TT><FONT FACE="Courier New">}
///:~</FONT></TT><BR></P></DIV>

<DIV ALIGN="LEFT"><P>The output from this code looks like this:<BR></P></DIV>
<DIV ALIGN="LEFT"><P><TT><FONT FACE="Courier New">2 2</FONT></TT><BR></P></DIV>

<DIV ALIGN="LEFT"><P>However, there is one important difference between <B>[ ]</B>
and <B>at(&#160;)</B>. When you try to reference an array element that is out of
bounds, <B>at(&#160;) </B>will do you the kindness of throwing an exception,
while ordinary <B>[ ] </B>subscripting syntax will leave you to your own
devices:<BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C01:BadStringIndexing.cpp</font>
#include &lt;string&gt;
#include &lt;iostream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main(){
  string s(<font color=#004488>"1234"</font>);
  <font color=#009900>// Runtime problem: goes beyond array bounds:</font>
  cout &lt;&lt; s[5] &lt;&lt; endl;
  <font color=#009900>// Saves you by throwing an exception:</font>
  cout &lt;&lt; s.at(5) &lt;&lt; endl;</PRE></FONT></BLOCKQUOTE><DIV ALIGN="LEFT"><P><TT><FONT FACE="Courier New">}
///:~</FONT></TT><BR></P></DIV>

<DIV ALIGN="LEFT"><P>Using <B>at(&#160;) </B>in place of <B>[ ] </B>will give you a
chance to gracefully recover from references to array elements that don&#8217;t
exist. <B>at(&#160;)</B> throws an object of class <B>out_of_range. </B>By
catching this object in an exception handler, you can take appropriate remedial
actions such as recalculating the offending subscript or growing the array. (You
can read more about Exception Handling in Chapter
XX)<A NAME="_Toc462393378"></A><BR></P></DIV>
<A NAME="Heading37"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Using iterators</H3></FONT>
<DIV ALIGN="LEFT"><P>In the example program <B>NewFind.cpp</B>, we used a lot of
messy and rather tedious C <B>char</B> array handling code to change the case of
the characters in a string and then search for the occurrence of matches to a
substring. Sometimes the &#8220;quick and dirty&#8221; method is justifiable,
but in general, you won&#8217;t want to sacrifice the advantages of having your
string data safely and securely encapsulated in the C++ object where it lives.
<BR></P></DIV>
<DIV ALIGN="LEFT"><P>Here is a better, safer way to handle case insensitive
comparison of two C++ string objects. Because no data is copied out of the
objects and into C style strings, you don&#8217;t have to use pointers and you
don&#8217;t have to risk overwriting the bounds of an ordinary character array.
In this example, we use the string <B>iterator</B>. Iterators are themselves
objects which move through a collection or container of other objects, selecting
them one at a time, but never providing direct access to the implementation of
the container. Iterators are <I>not</I> pointers, but they are useful for many
of the same jobs.<BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C01:CmpIter.cpp</font>
<font color=#009900>// Find a group of characters in a string</font>
#include &lt;string&gt;
#include &lt;iostream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#009900>// Case insensitive compare function:</font>
<font color=#0000ff>int</font> 
stringCmpi(<font color=#0000ff>const</font> string&amp; s1, <font color=#0000ff>const</font> string&amp; s2) {
  <font color=#009900>// Select the first element of each string:</font>
  string::const_iterator 
    p1 = s1.begin(), p2 = s2.begin();
  <font color=#009900>// Don&#8217;t run past the end:</font>
  <font color=#0000ff>while</font>(p1 != s1.end() &amp;&amp; p2 != s2.end()) {
    <font color=#009900>// Compare upper-cased chars:</font>
    <font color=#0000ff>if</font>(toupper(*p1) != toupper(*p2))
      <font color=#009900>// Report which was lexically  greater:</font>
      <font color=#0000ff>return</font> (toupper(*p1)&lt;toupper(*p2))? -1 : 1;
    p1++;
    p2++;
  }
  <font color=#009900>// If they match up to the detected eos, say </font>
  <font color=#009900>// which was longer. Return 0 if the same.</font>
  <font color=#0000ff>return</font>(s2.size() - s1.size());
}

<font color=#0000ff>int</font> main() {
  string s1(<font color=#004488>"Mozart"</font>);
  string s2(<font color=#004488>"Modigliani"</font>);
  cout &lt;&lt; stringCmpi(s1, s2) &lt;&lt; endl;</PRE></FONT></BLOCKQUOTE><DIV ALIGN="LEFT"><P><TT><FONT FACE="Courier New">}
///:~</FONT></TT><BR></P></DIV>

<DIV ALIGN="LEFT"><P>Notice that the iterators <B>p1</B> and <B>p2</B> use the same
syntax as C pointers &#8211; the &#8216;<B>*</B>&#8217; operator makes the
<I>value of</I> element at the location given by the iterators available to the
<B>toupper(&#160;) </B>function. <B>toupper(&#160;) </B>doesn&#8217;t actually
change the content of the element in the string. In fact, it can&#8217;t. This
definition of <B>p1</B> tells us that we can only use the elements <B>p1</B>
points to as constants. <BR></P></DIV>
<DIV ALIGN="LEFT"><P><TT><FONT FACE="Courier New">string::const_iterator p1 =
s1.begin();</FONT></TT><BR></P></DIV>

<DIV ALIGN="LEFT"><P>The way <B>toupper(&#160;)</B> and the iterators are used in
this example is called a <I>case preserving </I>case insensitive comparison.
This means that the string didn&#8217;t have to be copied or rewritten to
accommodate case insensitive comparison. Both of the strings retain their
original data, unmodified.<BR></P></DIV>
<A NAME="Heading38"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Iterating in reverse</H4></FONT>
<DIV ALIGN="LEFT"><P>Just as the standard C pointer gives us the increment (++) and
decrement (--) operators to make pointer arithmetic a bit more convenient, C++
string iterators come in two basic varieties. You&#8217;ve seen
<B>end(&#160;)</B> and <B>begin(&#160;)</B>, which are the tools for moving
forward through a string one element at a time. The reverse iterators
<B>rend(&#160;)</B> and <B>rbegin(&#160;)</B> allow you to step backwards
through a string. Here&#8217;s how they work:<BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C01:RevStr.cpp</font>
<font color=#009900>// Print a string in reverse</font>
#include &lt;string&gt;
#include &lt;iostream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;
<font color=#0000ff>int</font> main() {
  string s(<font color=#004488>"987654321"</font>);
  <font color=#009900>// Use this iterator to walk backwards:</font>
  string::reverse_iterator rev;
  <font color=#009900>// "Incrementing" the reverse iterator moves </font>
  <font color=#009900>// it to successively lower string elements:</font>
  <font color=#0000ff>for</font>(rev = s.rbegin(); rev != s.rend(); rev++)
    cout &lt;&lt; *rev &lt;&lt; <font color=#004488>" "</font>;</PRE></FONT></BLOCKQUOTE><DIV ALIGN="LEFT"><P><TT><FONT FACE="Courier New">}
///:~</FONT></TT><BR></P></DIV>

<DIV ALIGN="LEFT"><P>The output from <B>RevStr.cpp</B> looks like this:<BR></P></DIV>
<DIV ALIGN="LEFT"><P><TT><FONT FACE="Courier New">1 2 3 4 5 6 7 8
9</FONT></TT><BR></P></DIV>

<DIV ALIGN="LEFT"><P>Reverse iterators act like pointers to elements of the
string&#8217;s character array, <I>except that when you apply the increment
operator to them, they move backward rather than forward</I>.
<B>rbegin(&#160;)</B> and <B>rend(&#160;)</B> supply string locations that are
consistent with this behavior, to wit, <B>rbegin(&#160;)</B> locates the
position just beyond the end of the string, and <B>rend(&#160;)</B> locates the
beginning. Aside from this, the main thing to remember about reverse iterators
is that they <I>aren&#8217;t</I> type equivalent to ordinary iterators. For
example, if a member function parameter list includes an iterator as an
argument, you can&#8217;t substitute a reverse iterator to get the function to
perform it&#8217;s job walking backward through the string. Here&#8217;s an
illustration:<BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>// The compiler won&#8217;t accept this</font></PRE></FONT></BLOCKQUOTE><DIV ALIGN="LEFT"><P><TT><FONT FACE="Courier New">string
sBackwards(s.rbegin(), s.rend());</FONT></TT><BR></P></DIV>

<DIV ALIGN="LEFT"><P>The string constructor won&#8217;t accept reverse iterators in
place of forward iterators in its parameter list. This is also true of string
members such as <B>copy(&#160;)</B>, <B>insert(&#160;),</B> and
<B>assign(&#160;).</B><A NAME="_Toc462393379"></A><BR></P></DIV>
<A NAME="Heading39"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Strings and character traits</H3></FONT>
<DIV ALIGN="LEFT"><P>We seem to have worked our way around the margins of case
insensitive string comparisons using C++ string objects, so maybe it&#8217;s
time to ask the obvious question: &#8220;Why isn&#8217;t case-insensitive
comparison part of the standard <B>string</B> class ?&#8221; The answer provides
interesting background on the true nature of C++ string objects. <BR></P></DIV>
<DIV ALIGN="LEFT"><P>Consider what it means for a character to have
&#8220;case.&#8221; Written Hebrew, Farsi, and Kanji don&#8217;t use the concept
of upper and lower case, so for those languages this idea has no meaning at all.
This the first impediment to built-in C++ support for case-insensitive character
search and comparison: the idea of case sensitivity is not universal, and
therefore not portable. <BR></P></DIV>
<DIV ALIGN="LEFT"><P>It would seem that if there were a way of designating that
some languages were &#8220;all uppercase&#8221; or &#8220;all lowercase&#8221;
we could design a generalized solution. However, some languages which employ the
concept of &#8220;case&#8221; <I>also</I> change the meaning of particular
characters with diacritical marks: the cedilla in Spanish, the circumflex in
French, and the umlaut in German. For this reason, any case-sensitive collating
scheme that attempts to be comprehensive will be nightmarishly complex to use.
<BR></P></DIV>
<DIV ALIGN="LEFT"><P>Although we usually treat the C++ <B>string</B> as a class,
this is really not the case. <B>string</B> is a <B>typedef</B> of a more general
constituent, the <B>basic_string&lt;</B>&#160;<B>&gt;</B> template. Observe how
<B>string</B> is declared in the standard C++ header file:<BR></P></DIV>
<DIV ALIGN="LEFT"><P><TT><FONT FACE="Courier New">typedef basic_string&lt;char&gt;
string;</FONT></TT><BR></P></DIV>

<DIV ALIGN="LEFT"><P>To really understand the nature of strings, it&#8217;s helpful
to delve a bit deeper and look at the template on which it is based.
Here&#8217;s the declaration of the <B>basic_string&lt;</B>&#160;<B>&gt;</B>
template:<BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>template</font>&lt;<font color=#0000ff>class</font> charT,
  <font color=#0000ff>class</font> traits = char_traits&lt;charT&gt;,
  <font color=#0000ff>class</font> allocator = allocator&lt;charT&gt; &gt;</PRE></FONT></BLOCKQUOTE><DIV ALIGN="LEFT"><P><TT><FONT FACE="Courier New">
class basic_string;</FONT></TT><BR></P></DIV>

<DIV ALIGN="LEFT"><P>Earlier in this book, templates were examined in a great deal
of detail. The main thing to notice about the two declarations above are that
the <B>string</B> type is created when the <B>basic_string</B> template is
instantiated with <B>char. </B>Inside the <B>basic_string&lt;</B>&#160;<B>&gt;
</B>template declaration, the line <BR></P></DIV>
<DIV ALIGN="LEFT"><P><TT><FONT FACE="Courier New">class traits =
char_traits&lt;charT&gt;,</FONT></TT><BR></P></DIV>

<DIV ALIGN="LEFT"><P>tells us that the behavior of the class made from the
<B>basic_string&lt;</B>&#160;<B>&gt; </B>template is specified by a class based
on the template <B>char_traits&lt;</B>&#160;<B>&gt;</B>. Thus, the
<B>basic_string&lt;</B>&#160;<B>&gt;</B> template provides for cases where you
need string oriented classes that manipulate types other than <B>char</B> (wide
characters or unicode, for example). To do this, the
<B>char_traits&lt;</B>&#160;<B>&gt; </B>template controls the content and
collating behaviors of a variety of character sets using the character
comparison functions <B>eq(&#160;)</B> (equal), <B>ne(&#160;)</B> (not equal),
and <B>lt(&#160;)</B> (less than) upon which the
<B>basic_string&lt;</B>&#160;<B>&gt; </B>string comparison functions
rely.<BR></P></DIV>
<DIV ALIGN="LEFT"><P>This is why the string class doesn&#8217;t include case
insensitive member functions: That&#8217;s not in its job description. To change
the way the string class treats character comparison, you must supply a
different <B>char_traits&lt;</B>&#160;<B>&gt;</B> template, because that defines
the behavior of the individual character comparison member functions. <BR></P></DIV>
<DIV ALIGN="LEFT"><P>This information can be used to make a new type of <B>string
</B>class that ignores case. First, we&#8217;ll define a new case insensitive
<B>char_traits&lt;</B>&#160;<B>&gt;</B> template that inherits the existing one.
Next, we&#8217;ll override only the members we need to change in order to make
character-by-character comparison case insensitive. (In addition to the three
lexical character comparison members mentioned above, we&#8217;ll also have to
supply new implementation of <B>find(&#160;)</B> and <B>compare(&#160;)</B>.)
Finally, we&#8217;ll <B>typedef</B> a new class based on <B>basic_string</B>,
but using the case insensitive <B>ichar_traits</B> template for its second
argument.<BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C01:ichar_traits.h</font>
<font color=#009900>// Creating your own character traits</font>
#ifndef ICHAR_TRAITS_H
#define ICHAR_TRAITS_H
#include &lt;string&gt;
#include &lt;cctype&gt;

<font color=#0000ff>struct</font> ichar_traits : std::char_traits&lt;<font color=#0000ff>char</font>&gt; {
  <font color=#009900>// We'll only change character by </font>
  <font color=#009900>// character comparison functions</font>
  <font color=#0000ff>static</font> <font color=#0000ff>bool</font> eq(<font color=#0000ff>char</font> c1st, <font color=#0000ff>char</font> c2nd) {
    <font color=#0000ff>return</font> 
      std::toupper(c1st) == std::toupper(c2nd);
  }
  <font color=#0000ff>static</font> <font color=#0000ff>bool</font> ne(<font color=#0000ff>char</font> c1st, <font color=#0000ff>char</font> c2nd) {
    <font color=#0000ff>return</font> 
      std::toupper(c1st) != std::toupper(c2nd);
  }
  <font color=#0000ff>static</font> <font color=#0000ff>bool</font> lt(<font color=#0000ff>char</font> c1st, <font color=#0000ff>char</font> c2nd) {
    <font color=#0000ff>return</font> 
      std::toupper(c1st) &lt; std::toupper(c2nd);
  }
  <font color=#0000ff>static</font> <font color=#0000ff>int</font> compare(<font color=#0000ff>const</font> <font color=#0000ff>char</font>* str1, 
    <font color=#0000ff>const</font> <font color=#0000ff>char</font>* str2, size_t n) {
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; n; i++) {
      <font color=#0000ff>if</font>(std::tolower(*str1)&gt;std::tolower(*str2))
        <font color=#0000ff>return</font> 1;
      <font color=#0000ff>if</font>(std::tolower(*str1)&lt;std::tolower(*str2))
        <font color=#0000ff>return</font> -1;
      <font color=#0000ff>if</font>(*str1 == 0 || *str2 == 0)
        <font color=#0000ff>return</font> 0;
      str1++; str2++; <font color=#009900>// Compare the other chars</font>
    }
    <font color=#0000ff>return</font> 0;
  }
  <font color=#0000ff>static</font> <font color=#0000ff>const</font> <font color=#0000ff>char</font>* find(<font color=#0000ff>const</font> <font color=#0000ff>char</font>* s1, 
    <font color=#0000ff>int</font>  n, <font color=#0000ff>char</font> c) {
    <font color=#0000ff>while</font>(n-- &gt; 0 &amp;&amp;  
      std::toupper(*s1) != std::toupper(c))
      s1++;
    <font color=#0000ff>return</font> s1;
  }
};</PRE></FONT></BLOCKQUOTE><DIV ALIGN="LEFT"><P><TT><FONT FACE="Courier New">#endif // ICHAR_TRAITS_H 
///:~</FONT></TT><BR></P></DIV>

<DIV ALIGN="LEFT"><P>If we <B>typedef </B>an <B>istring</B> class like
this:<BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>typedef</font> basic_string&lt;<font color=#0000ff>char</font>, ichar_traits, </PRE></FONT></BLOCKQUOTE><DIV ALIGN="LEFT"><P><TT><FONT FACE="Courier New">
allocator&lt;char&gt; &gt; istring;</FONT></TT><BR></P></DIV>

<DIV ALIGN="LEFT"><P>Then this <B>istring</B> will act like an ordinary
<B>string</B> in every way, except that it will make all comparisons without
respect to case. Here&#8217;s an example:<BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C01:ICompare.cpp</font>
#include <font color=#004488>"ichar_traits.h"</font>
#include &lt;string&gt;
#include &lt;iostream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>typedef</font> basic_string&lt;<font color=#0000ff>char</font>, ichar_traits, 
  allocator&lt;<font color=#0000ff>char</font>&gt; &gt; istring;

<font color=#0000ff>int</font> main() {
  <font color=#009900>// The same letters except for case:</font>
  istring first = <font color=#004488>"tHis"</font>;
  istring second = <font color=#004488>"ThIS"</font>;
  cout &lt;&lt; first.compare(second) &lt;&lt; endl;</PRE></FONT></BLOCKQUOTE><DIV ALIGN="LEFT"><P><TT><FONT FACE="Courier New">}
///:~</FONT></TT><BR></P></DIV>

<DIV ALIGN="LEFT"><P>The output from the program is &#8220;0&#8221;, indicating
that the strings compare as equal. This is just a simple example &#8211; in
order to make <B>istring</B> fully equivalent to <B>string</B>, we&#8217;d have
to create the other functions necessary to support the new <B>istring</B>
type.<A NAME="_Toc462393380"></A><BR></P></DIV>
<A NAME="Heading40"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
A string application</H2></FONT>
<DIV ALIGN="LEFT"><P>My friend Daniel (who designed the cover and page layout for
this book) does a lot of work with Web pages. One tool he uses creates a
&#8220;site map&#8221; consisting of a Java applet to display the map and an
HTML tag that invoked the applet and provided it with the necessary data to
create the map. Daniel wanted to use this data to create an ordinary HTML page
(sans applet) that would contain regular links as the site map. The resulting
program turns out to be a nice practical application of the <B>string</B> class,
so it is presented here.<BR></P></DIV>
<DIV ALIGN="LEFT"><P>The input is an HTML file that contains the usual stuff along
with an applet tag with a parameter that begins like this:<BR></P></DIV>
<DIV ALIGN="LEFT"><P><TT><FONT FACE="Courier New">&lt;param name="source_file"
value="</FONT></TT><BR></P></DIV>

<DIV ALIGN="LEFT"><P>The rest of the line contains encoded information about the
site map, all combined into a single line (it&#8217;s rather long, but
fortunately <B>string</B> objects don&#8217;t care). Each entry may or may not
begin with a number of &#8216;<B>#</B>&#8217; signs; each of these indicates one
level of depth. If no &#8216;<B>#</B>&#8217; sign is present the entry will be
considered to be at level one. After the &#8216;<B>#</B>&#8217; is the text to
be displayed on the page, followed by a &#8216;<B>%</B>&#8217; and the URL to
use as the link. Each entry is terminated by a &#8216;<B>*</B>&#8217;. Thus, a
single entry in the line might look like this:<BR></P></DIV>
<DIV ALIGN="LEFT"><P><TT><FONT FACE="Courier New">###|Useful
Art%./Build/useful_art.html*</FONT></TT><BR></P></DIV>

<DIV ALIGN="LEFT"><P>The &#8216;<B>|</B>&#8217; at the beginning is an artifact
that needs to be removed.<BR></P></DIV>
<DIV ALIGN="LEFT"><P>My solution was to create an <B>Item</B> class whose
constructor would take input text and create an object that contains the text to
be displayed, the URL and the level. The objects essentially parse themselves,
and at that point you can read any value you want. In <B>main(&#160;)</B>, the
input file is opened and read until the line contains the parameter that
we&#8217;re interested in. Everything but the site map codes are stripped away
from this <B>string</B>, and then it is parsed into <B>Item</B>
objects:<BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C01:SiteMapConvert.cpp</font>
<font color=#009900>// Using strings to create a custom conversion</font>
<font color=#009900>// program that generates HTML output</font>
#include <font color=#004488>"..</font><font color=#004488>/require.h"</font>
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;string&gt;
#include &lt;cstdlib&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>class</font> Item {
  string id, url;
  <font color=#0000ff>int</font> depth;
  string removeBar(string s) {
    <font color=#0000ff>if</font>(s[0] == '|')
      <font color=#0000ff>return</font> s.substr(1);
    <font color=#0000ff>else</font> <font color=#0000ff>return</font> s;
  }
<font color=#0000ff>public</font>:
  Item(string in, <font color=#0000ff>int</font>&amp; index) : depth(0) {
    <font color=#0000ff>while</font>(in[index] == '#' &amp;&amp; index &lt; in.size()){
      depth++;
      index++;
    }
    <font color=#009900>// 0 means no '#' marks were found:</font>
    <font color=#0000ff>if</font>(depth == 0) depth = 1;
    <font color=#0000ff>while</font>(in[index] != '%' &amp;&amp; index &lt; in.size())
      id += in[index++];
    id = removeBar(id);
    index++; <font color=#009900>// Move past '%'</font>
    <font color=#0000ff>while</font>(in[index] != '*' &amp;&amp; index &lt; in.size())
      url += in[index++];
    url = removeBar(url);
    index++; <font color=#009900>// To move past '*'</font>
  }
  string identifier() { <font color=#0000ff>return</font> id; }
  string path() { <font color=#0000ff>return</font> url; }
  <font color=#0000ff>int</font> level() { <font color=#0000ff>return</font> depth; }
};

<font color=#0000ff>int</font> main(<font color=#0000ff>int</font> argc, <font color=#0000ff>char</font>* argv[]) {
  requireArgs(argc, 1,
    <font color=#004488>"usage: SiteMapConvert inputfilename"</font>);
  ifstream in(argv[1]);
  assure(in, argv[1]);
  ofstream out(<font color=#004488>"plainmap.html"</font>);
  string line;
  <font color=#0000ff>while</font>(getline(in, line)) {
    <font color=#0000ff>if</font>(line.find(<font color=#004488>"&lt;param name=\"</font>source_file\<font color=#004488>""</font>)
       != string::npos) {
      <font color=#009900>// Extract data from start of sequence</font>
      <font color=#009900>// until the terminating quote mark:</font>
      line = line.substr(line.find(<font color=#004488>"value=\"</font>") 
             + string(<font color=#004488>"value=\"</font>").size());
      line = line.substr(0, 
               line.find_last_of(<font color=#004488>"\"</font>"));
      <font color=#0000ff>int</font> index = 0;
      <font color=#0000ff>while</font>(index &lt; line.size()) {
        Item item(line, index);
        string startLevel, endLevel;
        <font color=#0000ff>if</font>(item.level() == 1) {
          startLevel = <font color=#004488>"&lt;h1&gt;"</font>;
          endLevel = <font color=#004488>"&lt;</font><font color=#004488>/h1&gt;"</font>;
        } <font color=#0000ff>else</font>
          <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; item.level(); i++)
            <font color=#0000ff>for</font>(<font color=#0000ff>int</font> j = 0; j &lt; 5; j++)
              out &lt;&lt; <font color=#004488>"&amp;nbsp;"</font>;
        string htmlLine = <font color=#004488>"&lt;a href=\"</font>"
          + item.path() + <font color=#004488>"\"</font>&gt;"
          + item.identifier() + <font color=#004488>"&lt;</font><font color=#004488>/a&gt;&lt;br&gt;"</font>;
        out &lt;&lt; startLevel &lt;&lt; htmlLine 
            &lt;&lt; endLevel &lt;&lt; endl;
      }
      <font color=#0000ff>break</font>; <font color=#009900>// Out of while loop</font>
    }
  }</PRE></FONT></BLOCKQUOTE><DIV ALIGN="LEFT"><P><TT><FONT FACE="Courier New">}
///:~</FONT></TT><BR></P></DIV>

<DIV ALIGN="LEFT"><P><B>Item</B> contains a private member function
<B>removeBar(&#160;)</B> that is used internally to strip off the leading bars,
if they appear.<BR></P></DIV>
<DIV ALIGN="LEFT"><P>The constructor for <B>Item</B> initializes <B>depth</B> to
<B>0</B> to indicate that no &#8216;#&#8217; signs were found yet; if none are
found then it is assumed the <B>Item</B> should be displayed at level one. Each
character in the <B>string</B> is examined using <B>operator[&#160;]</B> to find
the <B>depth</B>, <B>id</B> and <B>url</B> values. The other member functions
simply return these values.<BR></P></DIV>
<DIV ALIGN="LEFT"><P>After opening the files, <B>main(&#160;)</B> uses
<B>string::find(&#160;)</B> to locate the line containing the site map data. At
this point, <B>substr(&#160;)</B> is used in order to strip off the information
before and after the site map data. The subsequent <B>while</B> loop performs
the parsing, but notice that the value <B>index</B> is passed <I>by
reference</I> into the <B>Item</B> constructor, and that constructor increments
<B>index</B> as it parses each new <B>Item</B>, thus moving forward in the
sequence.<BR></P></DIV>
<DIV ALIGN="LEFT"><P>If an <B>Item</B> is at level one, then an HTML <B>h1</B> tag
is used, otherwise the elements are indented using HTML non-breaking spaces.
Note in the initialization of <B>htmlLine</B> how easy it is to construct a
<B>string</B> &#8211; you can just combine quoted character arrays and other
<B>string</B> objects using <B>operator+</B>.<BR></P></DIV>
<DIV ALIGN="LEFT"><P>When the output is written to the destination file,
<B>startLevel</B> and <B>endLevel</B> will only produce results if they have
been given any value other than their default initialization
values.<A NAME="_Toc462393381"></A><BR></P></DIV>
<A NAME="Heading41"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Summary</H2></FONT>
<DIV ALIGN="LEFT"><P>C++ string objects provide developers with a number of great
advantages over their C counterparts. For the most part, the <B>string</B> class
makes referring to strings through the use of character pointers unnecessary.
This eliminates an entire class of software defects that arise from the use of
uninitialized and incorrectly valued pointers. C++ strings dynamically and
transparently grow their internal data storage space to accommodate increases in
the size of the string data. This means that when the data in a string grows
beyond the limits of the memory initially allocated to it, the string object
will make the memory management calls that take space from and return space to
the heap. Consistent allocation schemes prevent memory leaks and have the
potential to be much more efficient than &#8220;roll your own&#8221; memory
management.<BR></P></DIV>
<DIV ALIGN="LEFT"><P>The <B>string</B> class member functions provide a fairly
comprehensive set of tools for creating, modifying, and searching in strings.
<B>string</B> comparisons are always case sensitive, but you can work around
this by copying string data to C style null terminated strings and using case
insensitive string comparison functions, temporarily converting the data held in
sting objects to a single case, or by creating a case insensitive string class
which overrides the character traits used to create the <B>basic_string</B>
object.<A NAME="_Toc462393382"></A><BR></P></DIV>
<A NAME="Heading42"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Exercises</H2></FONT>
<OL>
<LI>	A palindrome is a word or group of words that read the same forward and
backward. For example &#8220;madam&#8221; or &#8220;wow&#8221;. Write a program
that takes a string argument from the command line and returns TRUE if the
string was a palindrome.<LI>	Sometimes the input from a file stream contains a
two character sequence to represent a newline. These two characters (0x0a 0x0d)
produce extra blank lines when the stream is printed to standard out. Write a
program that finds the character 0x0d (ASCII carriage return) and deletes it
from the string.<LI>	Write a program that reverses the order of the characters
in a string.</OL>
<HR><DIV ALIGN="LEFT"><P><A NAME="fn4" HREF="#fnB4">[4]</A><FONT SIZE=2> Much of the
material in this chapter was originally created by Nancy
Nicolaisen</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="fn5" HREF="#fnB5">[5]</A><FONT SIZE=2> I subsequently
found better tools to accomplish this task, but the program is still
interesting.</FONT><BR></P></DIV>

<DIV ALIGN="CENTER">
    <FONT FACE="Verdana" size = "-1">
     [ <a href="Part1.html">Previous Chapter</a> ] 
    [ <a href="SimpleContents.html">Short TOC</a> ] 
    [ <a href="Contents.html">Table of Contents</a> ] 
    [ <a href="DocIndex.html">Index</a> ]
     [ <a href="Chapter02.html">Next Chapter</a> ] 
    </FONT>
    <BR>
 Last Update:05/23/2000</P></DIV>

</BODY>

</HTML>
