<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<!--
This document was converted from RTF source: 
By rtftohtml 4.19
See http://www.sunpack.com/RTF
Filename:TicV2.rtf
Application Directory:c:\TOOLS\RTF2HTML\
Subject:
Author:Bruce Eckel
Operator:Bruce Eckel
Document Comments:
Version Comments:
Comments:
Keywords:
Translation Date:05/23/2000
Translation Time:06:43:39
Translation Platform:Win32
Number of Output files:19
This File:Contents.html
SplitDepth=1
SkipNavPanel=1
SkipLeadingToc=1
SkipTrailingToc=1
GenContents=1
GenFrames=1
GenIndex=1
-->
<HEAD lang="en"><META http-equiv="Content-Type" content="text/html">
<TITLE>Thinking in C++, 2nd ed. Volume 2 Revision 3 - Contents</TITLE>
</HEAD>

<BODY  BGCOLOR="#FFFFFF"><H1>Thinking in C++, 2nd ed. Volume 2 Revision 3 - Contents </H1></FONT>
<H2><A HREF="Blank.html">Thinking in C++, 2nd ed. Volume 2 Revision 3 - Title Page </A></H2></FONT>
<UL>
<A HREF="Frontmatter.html">Thinking in C++ 2nd edition Volume 2: Standard Libraries &amp; Advanced Topics</A><BR>
<A HREF="Preface.html">Preface</A><BR>
<UL>
<A HREF="Preface.html#Heading3">What&#8217;s new in the second edition</A><BR>
<UL>
<A HREF="Preface.html#Heading4">What&#8217;s in Volume 2 of this book</A><BR>
<A HREF="Preface.html#Heading5">How to get Volume 2</A><BR>
</UL>
<A HREF="Preface.html#Heading6">Prerequisites</A><BR>
<A HREF="Preface.html#Heading7">Learning C++</A><BR>
<A HREF="Preface.html#Heading8">Goals</A><BR>
<A HREF="Preface.html#Heading9">Chapters</A><BR>
<A HREF="Preface.html#Heading10">Exercises</A><BR>
<UL>
<A HREF="Preface.html#Heading11">Exercise solutions</A><BR>
</UL>
<A HREF="Preface.html#Heading12">Source code</A><BR>
<A HREF="Preface.html#Heading13">Language standards</A><BR>
<UL>
<A HREF="Preface.html#Heading14">Language support</A><BR>
</UL>
<A HREF="Preface.html#Heading15">The book&#8217;s CD ROM</A><BR>
<A HREF="Preface.html#Heading16">Seminars, CD Roms &amp; consulting</A><BR>
<A HREF="Preface.html#Heading17">Errors</A><BR>
<A HREF="Preface.html#Heading18">Acknowledgements</A><BR>
</UL>
<A HREF="Part1.html">Part 1: The Standard C++ Library</A><BR>
<UL>
<A HREF="Part1.html#Heading20">Library overview</A><BR>
</UL>
<A HREF="Chapter01.html">1: Strings</A><BR>
<UL>
<A HREF="Chapter01.html#Heading22">What&#8217;s in a string</A><BR>
<UL>
<A HREF="Chapter01.html#Heading23">Creating and initializing C++ strings</A><BR>
<UL>
<A HREF="Chapter01.html#Heading24">Initialization limitations</A><BR>
</UL>
</UL>
<A HREF="Chapter01.html#Heading25">Operating on strings</A><BR>
<UL>
<A HREF="Chapter01.html#Heading26">Appending, inserting and concatenating strings</A><BR>
<A HREF="Chapter01.html#Heading27">Replacing string characters</A><BR>
<UL>
<A HREF="Chapter01.html#Heading28">Simple character replacement using the STL replace(&#160;) algorithm</A><BR>
</UL>
<A HREF="Chapter01.html#Heading29">Concatenation using non-member overloaded operators</A><BR>
</UL>
<A HREF="Chapter01.html#Heading30">Searching in strings</A><BR>
<UL>
<A HREF="Chapter01.html#Heading31">Finding in reverse</A><BR>
<A HREF="Chapter01.html#Heading32">Finding first/last of a set</A><BR>
<A HREF="Chapter01.html#Heading33">Removing characters from strings</A><BR>
<UL>
<A HREF="Chapter01.html#Heading34">Stripping HTML tags</A><BR>
</UL>
<A HREF="Chapter01.html#Heading35">Comparing strings </A><BR>
<UL>
<A HREF="Chapter01.html#Heading36">Indexing with [ ] vs. at(&#160;)</A><BR>
</UL>
<A HREF="Chapter01.html#Heading37">Using iterators</A><BR>
<UL>
<A HREF="Chapter01.html#Heading38">Iterating in reverse</A><BR>
</UL>
<A HREF="Chapter01.html#Heading39">Strings and character traits</A><BR>
</UL>
<A HREF="Chapter01.html#Heading40">A string application</A><BR>
<A HREF="Chapter01.html#Heading41">Summary</A><BR>
<A HREF="Chapter01.html#Heading42">Exercises</A><BR>
</UL>
<A HREF="Chapter02.html">2: Iostreams</A><BR>
<UL>
<A HREF="Chapter02.html#Heading44">Why iostreams?</A><BR>
<UL>
<A HREF="Chapter02.html#Heading45">True wrapping</A><BR>
</UL>
<A HREF="Chapter02.html#Heading46">Iostreams to the rescue</A><BR>
<UL>
<A HREF="Chapter02.html#Heading47">Sneak preview of operator overloading</A><BR>
<A HREF="Chapter02.html#Heading48">Inserters and extractors</A><BR>
<UL>
<A HREF="Chapter02.html#Heading49">Manipulators</A><BR>
</UL>
<A HREF="Chapter02.html#Heading50">Common usage</A><BR>
<A HREF="Chapter02.html#Heading51">Line-oriented input</A><BR>
<UL>
<A HREF="Chapter02.html#Heading52">Overloaded versions of get( )</A><BR>
<A HREF="Chapter02.html#Heading53">Reading raw bytes</A><BR>
<A HREF="Chapter02.html#Heading54">Error handling</A><BR>
</UL>
</UL>
<A HREF="Chapter02.html#Heading55">File iostreams</A><BR>
<UL>
<A HREF="Chapter02.html#Heading56">Open modes</A><BR>
</UL>
<A HREF="Chapter02.html#Heading57">Iostream buffering</A><BR>
<UL>
<A HREF="Chapter02.html#Heading58">Using get(&#160;) with a streambuf</A><BR>
</UL>
<A HREF="Chapter02.html#Heading59">Seeking in iostreams</A><BR>
<UL>
<A HREF="Chapter02.html#Heading60">Creating read/write files</A><BR>
</UL>
<A HREF="Chapter02.html#Heading61">stringstreams</A><BR>
<A HREF="Chapter02.html#Heading62">strstreams</A><BR>
<UL>
<A HREF="Chapter02.html#Heading63">User-allocated storage</A><BR>
<UL>
<A HREF="Chapter02.html#Heading64">Output strstreams</A><BR>
</UL>
<A HREF="Chapter02.html#Heading65">Automatic storage allocation</A><BR>
<UL>
<A HREF="Chapter02.html#Heading66">Proving movement</A><BR>
<A HREF="Chapter02.html#Heading67">A better way</A><BR>
</UL>
</UL>
<A HREF="Chapter02.html#Heading68">Output stream formatting</A><BR>
<UL>
<A HREF="Chapter02.html#Heading69">Internal formatting data</A><BR>
<UL>
<A HREF="Chapter02.html#Heading70">Format fields</A><BR>
<A HREF="Chapter02.html#Heading71">Width, fill and precision</A><BR>
</UL>
<A HREF="Chapter02.html#Heading72">An exhaustive example</A><BR>
</UL>
<A HREF="Chapter02.html#Heading73">Formatting manipulators</A><BR>
<UL>
<A HREF="Chapter02.html#Heading74">Manipulators with arguments</A><BR>
</UL>
<A HREF="Chapter02.html#Heading75">Creating manipulators</A><BR>
<UL>
<A HREF="Chapter02.html#Heading76">Effectors</A><BR>
</UL>
<A HREF="Chapter02.html#Heading77">Iostream examples</A><BR>
<UL>
<A HREF="Chapter02.html#Heading78">Code generation</A><BR>
<UL>
<A HREF="Chapter02.html#Heading79">Maintaining class library source</A><BR>
<A HREF="Chapter02.html#Heading80">Detecting compiler errors</A><BR>
</UL>
<A HREF="Chapter02.html#Heading81">A simple datalogger</A><BR>
<UL>
<A HREF="Chapter02.html#Heading82">Generating test data</A><BR>
<A HREF="Chapter02.html#Heading83">Verifying &amp; viewing the data</A><BR>
</UL>
<A HREF="Chapter02.html#Heading84">Counting editor</A><BR>
<A HREF="Chapter02.html#Heading85">Breaking up big files</A><BR>
</UL>
<A HREF="Chapter02.html#Heading86">Summary</A><BR>
<A HREF="Chapter02.html#Heading87">Exercises</A><BR>
</UL>
<A HREF="Chapter03.html">3: Templates in depth</A><BR>
<UL>
<A HREF="Chapter03.html#Heading89">Nontype template arguments</A><BR>
<A HREF="Chapter03.html#Heading90">Default template arguments</A><BR>
<A HREF="Chapter03.html#Heading91">The typename keyword</A><BR>
<UL>
<A HREF="Chapter03.html#Heading92">Typedefing a typename</A><BR>
<A HREF="Chapter03.html#Heading93">Using typename instead of class</A><BR>
</UL>
<A HREF="Chapter03.html#Heading94">Function templates</A><BR>
<UL>
<A HREF="Chapter03.html#Heading95">A string conversion system</A><BR>
<A HREF="Chapter03.html#Heading96">A memory allocation system</A><BR>
</UL>
<A HREF="Chapter03.html#Heading97">Type induction in function templates </A><BR>
<A HREF="Chapter03.html#Heading98">Taking the address of a generated function template </A><BR>
<A HREF="Chapter03.html#Heading99">Local classes in templates</A><BR>
<A HREF="Chapter03.html#Heading100">Applying a function to an STL sequence</A><BR>
<A HREF="Chapter03.html#Heading101">Template-templates</A><BR>
<A HREF="Chapter03.html#Heading102">Member function templates</A><BR>
<UL>
<A HREF="Chapter03.html#Heading103">Why virtual member template functions are disallowed</A><BR>
<A HREF="Chapter03.html#Heading104">Nested template classes</A><BR>
</UL>
<A HREF="Chapter03.html#Heading105">Template specializations</A><BR>
<UL>
<A HREF="Chapter03.html#Heading106">Full specialization</A><BR>
<A HREF="Chapter03.html#Heading107">Partial Specialization</A><BR>
<A HREF="Chapter03.html#Heading108">A practical example</A><BR>
<UL>
<A HREF="Chapter03.html#Heading109">Pointer specialization</A><BR>
<A HREF="Chapter03.html#Heading110">Partial ordering of function templates</A><BR>
</UL>
<A HREF="Chapter03.html#Heading111">Design &amp; efficiency</A><BR>
<A HREF="Chapter03.html#Heading112">Preventing template bloat</A><BR>
</UL>
<A HREF="Chapter03.html#Heading113">Explicit instantiation</A><BR>
<UL>
<A HREF="Chapter03.html#Heading114">Explicit specification of template functions</A><BR>
</UL>
<A HREF="Chapter03.html#Heading115">Controlling template instantiation</A><BR>
<UL>
<A HREF="Chapter03.html#Heading116">The inclusion vs. separation models</A><BR>
<A HREF="Chapter03.html#Heading117">The export keyword</A><BR>
</UL>
<A HREF="Chapter03.html#Heading118">Template programming idioms</A><BR>
<UL>
<A HREF="Chapter03.html#Heading119">The &#8220;curiously-recurring template&#8221;</A><BR>
<A HREF="Chapter03.html#Heading120">Traits</A><BR>
</UL>
<A HREF="Chapter03.html#Heading121">Summary</A><BR>
</UL>
<A HREF="Chapter04.html">4: STL Containers &amp; Iterators</A><BR>
<UL>
<A HREF="Chapter04.html#Heading123">Containers and iterators</A><BR>
<UL>
<A HREF="Chapter04.html#Heading124">STL reference documentation</A><BR>
</UL>
<A HREF="Chapter04.html#Heading125">The Standard Template Library </A><BR>
<A HREF="Chapter04.html#Heading126">The basic concepts</A><BR>
<A HREF="Chapter04.html#Heading127">Containers of strings</A><BR>
<A HREF="Chapter04.html#Heading128">Inheriting from STL containers</A><BR>
<A HREF="Chapter04.html#Heading129">A plethora of iterators</A><BR>
<UL>
<A HREF="Chapter04.html#Heading130">Iterators in reversible containers</A><BR>
<A HREF="Chapter04.html#Heading131">Iterator categories</A><BR>
<UL>
<A HREF="Chapter04.html#Heading132">Input: read-only, one pass</A><BR>
<A HREF="Chapter04.html#Heading133">Output: write-only, one pass</A><BR>
<A HREF="Chapter04.html#Heading134">Forward: multiple read/write</A><BR>
<A HREF="Chapter04.html#Heading135">Bidirectional: operator--</A><BR>
<A HREF="Chapter04.html#Heading136">Random-access: like a pointer</A><BR>
<A HREF="Chapter04.html#Heading137">Is this really important?</A><BR>
</UL>
<A HREF="Chapter04.html#Heading138">Predefined iterators</A><BR>
<UL>
<A HREF="Chapter04.html#Heading139">IO stream iterators</A><BR>
<A HREF="Chapter04.html#Heading140">Manipulating raw storage</A><BR>
</UL>
</UL>
<A HREF="Chapter04.html#Heading141">Basic sequences:  vector, list &amp; deque</A><BR>
<UL>
<A HREF="Chapter04.html#Heading142">Basic sequence operations</A><BR>
</UL>
<A HREF="Chapter04.html#Heading143">vector</A><BR>
<UL>
<A HREF="Chapter04.html#Heading144">Cost of overflowing allocated storage</A><BR>
<A HREF="Chapter04.html#Heading145">Inserting and erasing elements</A><BR>
</UL>
<A HREF="Chapter04.html#Heading146">deque</A><BR>
<UL>
<A HREF="Chapter04.html#Heading147">Converting between sequences</A><BR>
<A HREF="Chapter04.html#Heading148">Cost of overflowing allocated storage</A><BR>
<A HREF="Chapter04.html#Heading149">Checked random-access</A><BR>
</UL>
<A HREF="Chapter04.html#Heading150">list</A><BR>
<UL>
<A HREF="Chapter04.html#Heading151">Special list operations</A><BR>
<UL>
<A HREF="Chapter04.html#Heading152">list vs. set</A><BR>
</UL>
<A HREF="Chapter04.html#Heading153">Swapping all basic sequences</A><BR>
<A HREF="Chapter04.html#Heading154">Robustness of lists</A><BR>
</UL>
<A HREF="Chapter04.html#Heading155">Performance comparison</A><BR>
<A HREF="Chapter04.html#Heading156">set</A><BR>
<UL>
<A HREF="Chapter04.html#Heading157">Eliminating strtok(&#160;)</A><BR>
<A HREF="Chapter04.html#Heading158">StreamTokenizer:  a more flexible solution</A><BR>
<A HREF="Chapter04.html#Heading159">A completely reusable tokenizer</A><BR>
</UL>
<A HREF="Chapter04.html#Heading160">stack</A><BR>
<A HREF="Chapter04.html#Heading161">queue</A><BR>
<A HREF="Chapter04.html#Heading162">Priority queues</A><BR>
<A HREF="Chapter04.html#Heading163">Holding bits</A><BR>
<UL>
<A HREF="Chapter04.html#Heading164">bitset&lt;n&gt;</A><BR>
<A HREF="Chapter04.html#Heading165">vector&lt;bool&gt;</A><BR>
</UL>
<A HREF="Chapter04.html#Heading166">Associative containers</A><BR>
<UL>
<A HREF="Chapter04.html#Heading167">Generators and fillers  for associative containers</A><BR>
<A HREF="Chapter04.html#Heading168">The magic of maps</A><BR>
<UL>
<A HREF="Chapter04.html#Heading169">A command-line argument tool</A><BR>
</UL>
<A HREF="Chapter04.html#Heading170">Multimaps and duplicate keys</A><BR>
<A HREF="Chapter04.html#Heading171">Multisets</A><BR>
</UL>
<A HREF="Chapter04.html#Heading172">Combining STL containers</A><BR>
<A HREF="Chapter04.html#Heading173">Cleaning up  containers of pointers</A><BR>
<A HREF="Chapter04.html#Heading174">Creating your own containers</A><BR>
<A HREF="Chapter04.html#Heading175">Freely-available  STL extensions</A><BR>
<A HREF="Chapter04.html#Heading176">Summary</A><BR>
<A HREF="Chapter04.html#Heading177">Exercises</A><BR>
</UL>
<A HREF="Chapter05.html">5: STL Algorithms</A><BR>
<UL>
<A HREF="Chapter05.html#Heading179">Function objects</A><BR>
<UL>
<A HREF="Chapter05.html#Heading180">Classification of function objects</A><BR>
<A HREF="Chapter05.html#Heading181">Automatic creation of function objects</A><BR>
<UL>
<A HREF="Chapter05.html#Heading182">Binders</A><BR>
<A HREF="Chapter05.html#Heading183">Function pointer adapters</A><BR>
</UL>
<A HREF="Chapter05.html#Heading184">SGI extensions</A><BR>
</UL>
<A HREF="Chapter05.html#Heading185">A catalog of STL algorithms</A><BR>
<UL>
<A HREF="Chapter05.html#Heading186">Support tools for example creation</A><BR>
<A HREF="Chapter05.html#Heading187">Filling &amp; generating</A><BR>
<UL>
<A HREF="Chapter05.html#Heading188">Example</A><BR>
</UL>
<A HREF="Chapter05.html#Heading189">Counting</A><BR>
<UL>
<A HREF="Chapter05.html#Heading190">Example</A><BR>
</UL>
<A HREF="Chapter05.html#Heading191">Manipulating sequences</A><BR>
<UL>
<A HREF="Chapter05.html#Heading192">Example</A><BR>
</UL>
<A HREF="Chapter05.html#Heading193">Searching &amp; replacing</A><BR>
<UL>
<A HREF="Chapter05.html#Heading194">Example</A><BR>
</UL>
<A HREF="Chapter05.html#Heading195">Comparing ranges</A><BR>
<UL>
<A HREF="Chapter05.html#Heading196">Example</A><BR>
</UL>
<A HREF="Chapter05.html#Heading197">Removing elements</A><BR>
<UL>
<A HREF="Chapter05.html#Heading198">Example</A><BR>
</UL>
<A HREF="Chapter05.html#Heading199">Sorting and operations on sorted ranges</A><BR>
<UL>
<A HREF="Chapter05.html#Heading200">Sorting</A><BR>
<A HREF="Chapter05.html#Heading201">Example</A><BR>
<A HREF="Chapter05.html#Heading202">Locating elements in sorted ranges</A><BR>
<A HREF="Chapter05.html#Heading203">Example</A><BR>
<A HREF="Chapter05.html#Heading204">Merging sorted ranges</A><BR>
<A HREF="Chapter05.html#Heading205">Example</A><BR>
<A HREF="Chapter05.html#Heading206">Set operations on sorted ranges</A><BR>
<A HREF="Chapter05.html#Heading207">Example</A><BR>
</UL>
<A HREF="Chapter05.html#Heading208">Heap operations</A><BR>
<A HREF="Chapter05.html#Heading209">Applying an operation to each element in a range</A><BR>
<UL>
<A HREF="Chapter05.html#Heading210">Examples</A><BR>
</UL>
<A HREF="Chapter05.html#Heading211">Numeric algorithms</A><BR>
<UL>
<A HREF="Chapter05.html#Heading212">Example</A><BR>
</UL>
<A HREF="Chapter05.html#Heading213">General utilities</A><BR>
</UL>
<A HREF="Chapter05.html#Heading214">Creating your own STL-style algorithms</A><BR>
<A HREF="Chapter05.html#Heading215">Summary</A><BR>
<A HREF="Chapter05.html#Heading216">Exercises</A><BR>
</UL>
<A HREF="Part2.html">Part 2: Advanced Topics</A><BR>
<A HREF="Chapter06.html">6: Multiple inheritance</A><BR>
<UL>
<A HREF="Chapter06.html#Heading219">Perspective</A><BR>
<A HREF="Chapter06.html#Heading220">Duplicate subobjects</A><BR>
<A HREF="Chapter06.html#Heading221">Ambiguous upcasting</A><BR>
<A HREF="Chapter06.html#Heading222">virtual base classes</A><BR>
<UL>
<A HREF="Chapter06.html#Heading223">The "most derived" class and virtual base initialization</A><BR>
<A HREF="Chapter06.html#Heading224">"Tying off" virtual bases with a default constructor</A><BR>
</UL>
<A HREF="Chapter06.html#Heading225">Overhead</A><BR>
<A HREF="Chapter06.html#Heading226">Upcasting</A><BR>
<UL>
<A HREF="Chapter06.html#Heading227">Persistence</A><BR>
<UL>
<A HREF="Chapter06.html#Heading228">MI-based persistence</A><BR>
<A HREF="Chapter06.html#Heading229">Improved persistence</A><BR>
</UL>
</UL>
<A HREF="Chapter06.html#Heading230">Avoiding MI</A><BR>
<A HREF="Chapter06.html#Heading231">Mixin types</A><BR>
<A HREF="Chapter06.html#Heading232">Repairing an interface</A><BR>
<A HREF="Chapter06.html#Heading233">Summary</A><BR>
<A HREF="Chapter06.html#Heading234">Exercises</A><BR>
</UL>
<A HREF="Chapter07.html">7: Exception handling</A><BR>
<UL>
<A HREF="Chapter07.html#Heading236">Error handling in C</A><BR>
<A HREF="Chapter07.html#Heading237">Throwing an exception</A><BR>
<A HREF="Chapter07.html#Heading238">Catching an exception</A><BR>
<UL>
<A HREF="Chapter07.html#Heading239">The try block</A><BR>
<A HREF="Chapter07.html#Heading240">Exception handlers</A><BR>
<UL>
<A HREF="Chapter07.html#Heading241">Termination vs. resumption</A><BR>
</UL>
<A HREF="Chapter07.html#Heading242">The exception specification</A><BR>
<UL>
<A HREF="Chapter07.html#Heading243">unexpected(&#160;)</A><BR>
<A HREF="Chapter07.html#Heading244">set_unexpected(&#160;)</A><BR>
</UL>
<A HREF="Chapter07.html#Heading245">Better exception specifications?</A><BR>
<A HREF="Chapter07.html#Heading246">Catching any exception</A><BR>
<A HREF="Chapter07.html#Heading247">Rethrowing an exception</A><BR>
<A HREF="Chapter07.html#Heading248">Uncaught exceptions</A><BR>
<UL>
<A HREF="Chapter07.html#Heading249">terminate(&#160;)</A><BR>
<A HREF="Chapter07.html#Heading250">set_terminate(&#160;)</A><BR>
</UL>
<A HREF="Chapter07.html#Heading251">Function-level try blocks</A><BR>
</UL>
<A HREF="Chapter07.html#Heading252">Cleaning up</A><BR>
<A HREF="Chapter07.html#Heading253">Constructors</A><BR>
<UL>
<A HREF="Chapter07.html#Heading254">Making everything an object</A><BR>
</UL>
<A HREF="Chapter07.html#Heading255">Exception matching</A><BR>
<A HREF="Chapter07.html#Heading256">Standard exceptions</A><BR>
<A HREF="Chapter07.html#Heading257">Programming with exceptions</A><BR>
<UL>
<A HREF="Chapter07.html#Heading258">When to avoid exceptions</A><BR>
<UL>
<A HREF="Chapter07.html#Heading259">Not for asynchronous events</A><BR>
<A HREF="Chapter07.html#Heading260">Not for ordinary error conditions</A><BR>
<A HREF="Chapter07.html#Heading261">Not for flow-of-control</A><BR>
<A HREF="Chapter07.html#Heading262">You&#8217;re not forced to use exceptions</A><BR>
<A HREF="Chapter07.html#Heading263">New exceptions, old code</A><BR>
</UL>
<A HREF="Chapter07.html#Heading264">Typical uses of exceptions</A><BR>
<UL>
<A HREF="Chapter07.html#Heading265">Always use exception specifications</A><BR>
<A HREF="Chapter07.html#Heading266">Start with standard exceptions</A><BR>
<A HREF="Chapter07.html#Heading267">Nest your own exceptions</A><BR>
<A HREF="Chapter07.html#Heading268">Use exception hierarchies</A><BR>
<A HREF="Chapter07.html#Heading269">Multiple inheritance</A><BR>
<A HREF="Chapter07.html#Heading270">Catch by reference, not by value</A><BR>
<A HREF="Chapter07.html#Heading271">Throw exceptions in constructors</A><BR>
<A HREF="Chapter07.html#Heading272">Don&#8217;t cause exceptions in destructors</A><BR>
<A HREF="Chapter07.html#Heading273">Avoid naked pointers</A><BR>
</UL>
</UL>
<A HREF="Chapter07.html#Heading274">Overhead</A><BR>
<A HREF="Chapter07.html#Heading275">Summary</A><BR>
<A HREF="Chapter07.html#Heading276">Exercises</A><BR>
</UL>
<A HREF="Chapter08.html">8: Run-time type identification</A><BR>
<UL>
<A HREF="Chapter08.html#Heading278">The &#8220;Shape&#8221; example</A><BR>
<A HREF="Chapter08.html#Heading279">What is RTTI?</A><BR>
<UL>
<A HREF="Chapter08.html#Heading280">Two syntaxes for RTTI</A><BR>
</UL>
<A HREF="Chapter08.html#Heading281">Syntax specifics</A><BR>
<UL>
<A HREF="Chapter08.html#Heading282">typeid(&#160;) with built-in types</A><BR>
<A HREF="Chapter08.html#Heading283">Producing the proper type name</A><BR>
<A HREF="Chapter08.html#Heading284">Nonpolymorphic types</A><BR>
<A HREF="Chapter08.html#Heading285">Casting to intermediate levels</A><BR>
<A HREF="Chapter08.html#Heading286">void pointers</A><BR>
<A HREF="Chapter08.html#Heading287">Using RTTI with templates</A><BR>
</UL>
<A HREF="Chapter08.html#Heading288">References</A><BR>
<UL>
<A HREF="Chapter08.html#Heading289">Exceptions</A><BR>
</UL>
<A HREF="Chapter08.html#Heading290">Multiple inheritance</A><BR>
<A HREF="Chapter08.html#Heading291">Sensible uses for RTTI</A><BR>
<UL>
<A HREF="Chapter08.html#Heading292">Revisiting the trash recycler</A><BR>
</UL>
<A HREF="Chapter08.html#Heading293">Mechanism &amp; overhead of RTTI</A><BR>
<A HREF="Chapter08.html#Heading294">Creating your own RTTI</A><BR>
<A HREF="Chapter08.html#Heading295">Explicit cast syntax</A><BR>
<A HREF="Chapter08.html#Heading296">Summary</A><BR>
<A HREF="Chapter08.html#Heading297">Exercises</A><BR>
</UL>
<A HREF="Chapter09.html">9: Building stable systems</A><BR>
<UL>
<A HREF="Chapter09.html#Heading299">Shared objects &amp; reference counting</A><BR>
<UL>
<A HREF="Chapter09.html#Heading300">Reference-counted class hierarchies</A><BR>
</UL>
<A HREF="Chapter09.html#Heading301">Finding memory leaks</A><BR>
<A HREF="Chapter09.html#Heading302">The canonical object &amp; singly-rooted hierarchies</A><BR>
<UL>
<A HREF="Chapter09.html#Heading303">An extended canonical form</A><BR>
</UL>
<A HREF="Chapter09.html#Heading304">Design by contract</A><BR>
<A HREF="Chapter09.html#Heading305">Integrated unit testing</A><BR>
<A HREF="Chapter09.html#Heading306">Dynamic aggregation</A><BR>
<A HREF="Chapter09.html#Heading307">Exercises</A><BR>
</UL>
<A HREF="Chapter10.html">10: Design patterns</A><BR>
<UL>
<A HREF="Chapter10.html#Heading309">The pattern concept</A><BR>
<UL>
<A HREF="Chapter10.html#Heading310">The singleton</A><BR>
<UL>
<A HREF="Chapter10.html#Heading311">Variations on singleton</A><BR>
</UL>
</UL>
<A HREF="Chapter10.html#Heading312">Classifying patterns</A><BR>
<UL>
<A HREF="Chapter10.html#Heading313">Features, idioms, patterns</A><BR>
<A HREF="Chapter10.html#Heading314">Basic complexity hiding</A><BR>
</UL>
<A HREF="Chapter10.html#Heading315">Factories: encapsulating object creation</A><BR>
<UL>
<A HREF="Chapter10.html#Heading316">Polymorphic factories</A><BR>
<A HREF="Chapter10.html#Heading317">Abstract factories</A><BR>
<A HREF="Chapter10.html#Heading318">Virtual constructorsBE</A><BR>
<UL>
<A HREF="Chapter10.html#Heading319">Destructor operation</A><BR>
</UL>
</UL>
<A HREF="Chapter10.html#Heading320">Callbacks</A><BR>
<UL>
<A HREF="Chapter10.html#Heading321">Functor/Command</A><BR>
<A HREF="Chapter10.html#Heading322">Strategy</A><BR>
<A HREF="Chapter10.html#Heading323">Observer</A><BR>
<UL>
<A HREF="Chapter10.html#Heading324">The &#8220;interface&#8221; idiom</A><BR>
<A HREF="Chapter10.html#Heading325">The &#8220;inner class&#8221; idiom</A><BR>
<A HREF="Chapter10.html#Heading326">The observer example</A><BR>
</UL>
</UL>
<A HREF="Chapter10.html#Heading327">Multiple dispatching</A><BR>
<UL>
<A HREF="Chapter10.html#Heading328">Visitor, a type of multiple dispatching</A><BR>
</UL>
<A HREF="Chapter10.html#Heading329">Efficiency</A><BR>
<UL>
<A HREF="Chapter10.html#Heading330">Flyweight</A><BR>
</UL>
<A HREF="Chapter10.html#Heading331">The composite</A><BR>
<A HREF="Chapter10.html#Heading332">Evolving a design: the trash recycler</A><BR>
<A HREF="Chapter10.html#Heading333">Improving the design</A><BR>
<UL>
<A HREF="Chapter10.html#Heading334">&#8220;Make more objects&#8221;</A><BR>
<A HREF="Chapter10.html#Heading335">A pattern for prototyping creation</A><BR>
<UL>
<A HREF="Chapter10.html#Heading336">Trash subclasses</A><BR>
<A HREF="Chapter10.html#Heading337">Parsing Trash from an external file</A><BR>
<A HREF="Chapter10.html#Heading338">Recycling with prototyping</A><BR>
</UL>
</UL>
<A HREF="Chapter10.html#Heading339">Abstracting usage</A><BR>
<A HREF="Chapter10.html#Heading340">Applying double dispatching</A><BR>
<UL>
<A HREF="Chapter10.html#Heading341">Implementing the double dispatch</A><BR>
</UL>
<A HREF="Chapter10.html#Heading342">Applying the visitor pattern</A><BR>
<UL>
<A HREF="Chapter10.html#Heading343">More coupling?</A><BR>
</UL>
<A HREF="Chapter10.html#Heading344">RTTI considered harmful?</A><BR>
<A HREF="Chapter10.html#Heading345">Summary</A><BR>
<A HREF="Chapter10.html#Heading346">Exercises</A><BR>
</UL>
<A HREF="Chapter11.html">11: Tools &amp; topics</A><BR>
<UL>
<A HREF="Chapter11.html#Heading348">The code extractor</A><BR>
<A HREF="Chapter11.html#Heading349">Debugging</A><BR>
<UL>
<A HREF="Chapter11.html#Heading350">assert(&#160;)</A><BR>
<A HREF="Chapter11.html#Heading351">Trace macros</A><BR>
<A HREF="Chapter11.html#Heading352">Trace file</A><BR>
<A HREF="Chapter11.html#Heading353">Abstract base class for debugging</A><BR>
<A HREF="Chapter11.html#Heading354">Tracking new/delete &amp; malloc/free</A><BR>
</UL>
<A HREF="Chapter11.html#Heading355">CGI programming in C++</A><BR>
<UL>
<A HREF="Chapter11.html#Heading356">Encoding data for CGI</A><BR>
<A HREF="Chapter11.html#Heading357">The CGI parser</A><BR>
<UL>
<A HREF="Chapter11.html#Heading358">Testing the CGI parser</A><BR>
</UL>
<A HREF="Chapter11.html#Heading359">Using POST</A><BR>
<A HREF="Chapter11.html#Heading360">Handling mailing lists</A><BR>
<UL>
<A HREF="Chapter11.html#Heading361">Maintaining your list</A><BR>
<A HREF="Chapter11.html#Heading362">Mailing to your list</A><BR>
</UL>
<A HREF="Chapter11.html#Heading363">A general information-extraction  CGI program</A><BR>
<A HREF="Chapter11.html#Heading364">Parsing the data files</A><BR>
</UL>
<A HREF="Chapter11.html#Heading365">Summary</A><BR>
<A HREF="Chapter11.html#Heading366">Exercises</A><BR>
</UL>
<A HREF="AppendixA.html">A: Recommended reading</A><BR>
<UL>
<A HREF="AppendixA.html#Heading368">C</A><BR>
<A HREF="AppendixA.html#Heading369">General C++</A><BR>
<UL>
<A HREF="AppendixA.html#Heading370">My own list of books </A><BR>
</UL>
<A HREF="AppendixA.html#Heading371">Depth &amp; dark corners</A><BR>
<A HREF="AppendixA.html#Heading372">The STL</A><BR>
<A HREF="AppendixA.html#Heading373">Design Patterns</A><BR>
</UL>
<A HREF="AppendixB.html">B: Etc</A><BR>
<A HREF="Blank2.html">Index</A><BR>
</UL>
</BODY>
</HTML>
